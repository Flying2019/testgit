### [链接](https://www.luogu.com.cn/problem/P4199)
### 题目大意
给定一个只含ab的字符串，求子序列个数，满足位置和字符都关于某对称轴对称且不全连续。
### 题解
首先，显然回文串是关于某对称轴对称且连续的。所以我们直接计算关于某对称轴对称的子序列个数减去回文串个数即可。

考虑如何计算关于某对称轴对称的子序列个数。可以发现，关于一个对称轴对称的字符对的下标和一定是一个定值。

假如下标和为 $x$ 的字符对个数为 $k$ 对，显然那么这个下标和对应的对称轴的贡献就是 $2^k-1$。

而字符串字符集只有2，显然对ab分别自卷，得出的结果就是答案。

显然任意一个对称轴的答案不超过 $10^5$，所以不必关注 $10^9+7$ 的模数，NTT/FTT照样写。

时间复杂度 $O(n\log n)$。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 400010
#define gmod 1000000007
#define mod 998244353
#define G 3
using namespace std;
int ksm(int a,int b,int p)
{
    int r=1;
    for(;b;b>>=1){if(b&1) r=1ll*r*a%p;a=1ll*a*a%p;}
    return r;
}
int rev[N];
int get_rev(int n)
{
    int l=0,lim=1;
    while(lim<n*2) l++,lim<<=1;
    for(int i=1;i<lim;i++)
    rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
    return lim;
}
void ntt(int f[],int lim,int opt)
{
    for(int i=0;i<lim;i++)
    if(i<rev[i]) swap(f[i],f[rev[i]]);
    for(int mid=1;mid<lim;mid<<=1)
    {
        int r=ksm(opt==1?G:ksm(G,mod-2,mod),(mod-1)/(mid*2),mod);
        for(int i=0;i<lim;i+=mid*2)
            for(int j=0,o=1;j<mid;j++,o=1ll*o*r%mod)
            {
                int x=f[i+j],y=1ll*f[i+j+mid]*o%mod;
                f[i+j]=(x+y)%mod;
                f[i+j+mid]=(x-y+mod)%mod;
            }
    }
    if(opt==-1)
    {
        int r=ksm(lim,mod-2,mod);
        for(int i=0;i<lim;i++) f[i]=1ll*f[i]*r%mod;
    }
}
char s[N],ss[N];
int s1[N],f[N],g[N],ans[N],p[N];
void manacher(int n)
{
    int m=n*2+1;
    ss[0]='$';
    for(int i=1;i<=n;i++)
    ss[i*2-1]='#',ss[i*2]=s[i];
    ss[m]='#';
    ss[m+1]='%';
    int maxn=-1,id,r=0;
    for(int i=1;i<=m;i++)
    {
        if(i<r) p[i]=min(p[2*id-i],r-i);
        else p[i]=1;
        while(ss[i-p[i]]==ss[i+p[i]]) p[i]++;
        if(r<i+p[i]) r=p[i]+i,id=i;
    }
}
int main()
{
    scanf("%s",s+1);
    int n=strlen(s+1),m=n*2+1;
    for(int i=1;i<=n;i++) s1[i]=s[i]=='a';
    for(int i=1;i<=n;i++) f[i]=g[i]=s1[i];
    int lim=get_rev(n+1);
    ntt(f,lim,1),ntt(g,lim,1);
    for(int i=0;i<lim;i++) f[i]=1ll*f[i]*g[i]%mod;
    ntt(f,lim,-1);
    for(int i=1;i<=m;i++) ans[i]+=(f[i]-((i&1)^1));
    memset(f,0,sizeof(f)),memset(g,0,sizeof(g));

    for(int i=1;i<=n;i++) f[i]=g[i]=s1[i]^1;
    ntt(f,lim,1),ntt(g,lim,1);
    for(int i=0;i<lim;i++) f[i]=1ll*f[i]*g[i]%mod;
    ntt(f,lim,-1);
    for(int i=1;i<=m;i++) ans[i]+=(f[i]-((i&1)^1));
    for(int i=1;i<=m;i++) ans[i]=((ans[i]+((i&1)^1))>>1)+((i&1)^1);
    int res=0;
    for(int i=1;i<=m;i++) res=(res+ksm(2,ans[i],gmod)-1)%gmod;
    manacher(n);
    for(int i=1;i<=m;i++) res=(res-(p[i]>>1)+gmod)%gmod;
    printf("%d\n",res);
    return 0;
}
```
