### [链接](https://loj.ac/problem/3158)
### 题目大意
给定两个序列 $A,B$，从每个序列中各选 $k$ 个数字，要求至少有 $l$ 个下标相同的数字。问选出结果的最大值。
### 题解
挺好的模拟费用流题。

首先部分分很有启发意义，我们不妨把限制看成“至多 $k-l$ 对不同下标的数字”，显然这样不会导致最大值变化。

不妨认为选择下标不同的数字为 “特殊流”，下标相同的数字为“一般流”。

那么这样就变成了一个二分图 $A,B$ 。我们考虑对于每一条增广路我们可以干什么：
1. 任意选两个两边的未被选上的点 $A_i,B_j$。要求下标不同的数字没有超过 $k-l$。（扩特殊流）
2. 选择一对下标相同且没有被选上的点 $A_i,B_j$。（扩一般流）
3. 选择一个没有被选上且对应点 $A_i$ 被选上的点 $B_i$，再选择一个其他可行点 $B_j$，进行匹配。（$A$ 退流）
4. 选择一个没有被选上且对应点 $B_i$ 被选上的点 $A_i$，再选择一个其他可行点 $A_j$，进行匹配。（$B$ 退流）

考虑如何处理：

首先考虑费用流的过程，显然如果我们有机会选更优的结果，先选更优的一定不会差。

再考虑一种贪心：首先如果有特殊流的流量，那么用掉一定不会差。其次，如果两个点下标相同，那么通过扩特殊流一定不比扩一般流优。

根据退流的原理，我们可以发现：对于两组匹配 $A_i\leftrightarrow B_j\ ,\ A_{i'}\leftrightarrow B_i$，交换匹配变成 $A_i\leftrightarrow B_i\ ,\ A_{i'}\leftrightarrow B_j$，这样可以省下一个特殊流的流量。

显然，先判断是否还有特殊流，那么这样的价值就是 $a_i+b_j$，直接用两个堆维护。

接下来我们对于剩下三种情况分别算出当前情况下的最大值。

考虑第二种，选 $i$ 的价值为 $a_i+b_i$，显然也可以用一个堆维护。

第三、四种的本质是求 $A/B$ 中对应点已经匹配的点中的最大值加上同第一种的最大值，这个也可以用两个堆维护。

特别的，每次操作完之后，需要判断是否可以进行退流操作，以省下尽可能多的特殊流。

时间复杂度 $O(n\log n)$。

~~**多测不清空，爆0两行泪**~~
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define ll long long
#define N 200010
using namespace std;
struct node{
    int v,id;
    node(int V=0,int I=0):v(V),id(I){}
    bool operator <(const node a)const{return v<a.v;}
};
priority_queue<node>qa,qb,qab,q0,q1;
int a[N],b[N];
int va[N],vb[N],fl;
void pop()
{
    while(!qa.empty() && va[qa.top().id]) qa.pop();
    while(!qb.empty() && vb[qb.top().id]) qb.pop();
    while(!qab.empty() && (va[qab.top().id] || vb[qab.top().id])) qab.pop();
    while(!q0.empty() && va[q0.top().id]) q0.pop();
    while(!q1.empty() && vb[q1.top().id]) q1.pop();
}
void pushfl(int x)
{
    if(!va[x] || !vb[x] || va[x]==x) return;
    int j=va[x],k=vb[x];
    va[x]=vb[x]=x;
    ++fl;
    va[k]=j;vb[j]=k;
    if(k==j) ++fl;
}
void clear(priority_queue<node> &a){while(!a.empty()) a.pop();}
int main()
{
    int t;
    scanf("%d",&t);
    while(t --> 0)
    {
        int n,k,l;
        scanf("%d%d%d",&n,&k,&l);
        clear(qa);clear(qb);clear(qab);clear(q0);clear(q1);fl=0;
        for(int i=1;i<=n;i++) va[i]=vb[i]=0;
        for(int i=1;i<=n;i++) scanf("%d",&a[i]);
        for(int i=1;i<=n;i++) scanf("%d",&b[i]);
        for(int i=1;i<=n;i++) qa.push(node(a[i],i)),qb.push(node(b[i],i)),qab.push(node(a[i]+b[i],i));
        fl=k-l;
        ll ans=0;
        for(int _=1;_<=k;_++)
        {
            pop();
            if(fl)
            {
                int u=qa.top().id,v=qb.top().id;
                qa.pop();qb.pop();
                ans+=a[u]+b[v];
                va[u]=v,vb[v]=u;
                if(u!=v)
                {
                    fl--;
                    if(!va[v]) q0.push(node(a[v],v));
                    if(!vb[u]) q1.push(node(b[u],u));
                    pushfl(u),pushfl(v);
                }
                continue;
            }
            int a1=0,a2=0,a3=0;
            if(!qab.empty()){int u=qab.top().id;a1=a[u]+b[u];}
            if(!q1.empty())
            {
                int u=q1.top().id,v=qa.top().id;
                a2=a[v]+b[u];
            }
            if(!q0.empty())
            {
                int u=q0.top().id,v=qb.top().id;
                a3=b[v]+a[u];
            }
            if(a3>a2 && a3>a1)
            {       
                int u=q0.top().id,v=qb.top().id;
                int k=vb[u];
                va[u]=vb[u]=u;
                va[k]=v,vb[v]=k;
                if(v==k) ++fl;
                if(!va[v]) q0.push(node(a[v],v));
                pushfl(v),pushfl(k);
            }
            else if(a2>=a3 && a2>a1)
            {
                int u=q1.top().id,v=qa.top().id;
                int k=va[u];
                vb[u]=va[u]=u;
                vb[k]=v,va[v]=k;
                if(v==k) ++fl;
                if(!vb[v]) q1.push(node(b[v],v));
                pushfl(v),pushfl(k);
            }
            else
            {
                int u=qab.top().id;
                va[u]=vb[u]=u;
            }
            ans+=max(max(a1,a2),a3);
        }
        printf("%lld\n",ans);
    }
    
    return 0;
}
```
