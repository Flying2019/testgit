### [链接](https://www.luogu.com.cn/problem/P4768)
首先考虑如果不能开车，显然就是求一次最短路。开车等同于合并联通块。

考虑假如没有强制在线，很显然这是一道很经典的题。直接将询问按降雨量从大到小排序，然后依次将可以开车的路两端节点合并即可。

显然一个带权并查集就能解决。

然后考虑强制在线，显然直接可持久化就行了。时间复杂度 $O(n\log^2 n)$。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#define N 400010
#define ll long long
using namespace std;
int nxt[N<<1],to[N<<1],len[N<<1],head[N],cnt;
void add(int u,int v,int w)
{
	nxt[++cnt]=head[u];
	to[cnt]=v;
	len[cnt]=w;
	head[u]=cnt;
}
int n,m;
ll dis[N];
namespace Dij{
	struct node{
		int u;
		ll dis;
		node(int U=0,ll Dis=0):u(U),dis(Dis){}
		bool operator <(const node a)const{return dis>a.dis;}
	};
	priority_queue<node>q;
	bool vis[N];
	void dij(int s)
	{
		for(int i=1;i<=n;i++) dis[i]=100000000000000ll,vis[i]=false;
		dis[s]=0;
		q.push(node(s,0));
		while(!q.empty())
		{
			int u=q.top().u;
			dis[u]=min(dis[u],q.top().dis);
			q.pop();
			if(vis[u]) continue;
			vis[u]=true;
			for(int i=head[u];i;i=nxt[i])
			{
				int v=to[i];
				if(dis[v]>dis[u]+len[i]) q.push(node(v,dis[u]+len[i]));
			}
		}
//		for(int i=1;i<=n;i++) printf("%d ",dis[i]);puts("");
	}
}
namespace DSU{
	#define M N*40
	int ls[M],rs[M],fa[M],root[N],dep[M],cnt;
	int tot;
	ll dis[M];
	void clear(){memset(root,0,sizeof(root));cnt=tot=0;}
	void build(int &u,int l,int r)
	{
		u=++cnt;
		if(l==r){fa[u]=l;dis[u]=::dis[l];return;}
		int mid=(l+r)>>1;
		build(ls[u],l,mid);build(rs[u],mid+1,r);
	}
	void insert(int &u,int pre,int l,int r,int p,int a)
	{
		u=++cnt;
		ls[u]=ls[pre],rs[u]=rs[pre];
		if(l==r){fa[u]=a;dep[u]=dep[pre];return;}
		int mid=(l+r)>>1;
		if(p<=mid) insert(ls[u],ls[pre],l,mid,p,a);
		else insert(rs[u],rs[pre],mid+1,r,p,a);
	}
	int get_fa(int u,int l,int r,int p)
	{
		if(l==r) return u;
		int mid=(l+r)>>1;
		if(p<=mid) return get_fa(ls[u],l,mid,p);
		else return get_fa(rs[u],mid+1,r,p);
	}
	void inc(int &u,int pre,int l,int r,int p,int o1,ll o2)
	{
		u=++cnt;
		ls[u]=ls[pre],rs[u]=rs[pre];
		if(l==r){dep[u]=dep[pre]==o1?dep[pre]+1:dep[pre];dis[u]=min(dis[pre],o2);fa[u]=fa[pre];return;}
		int mid=(l+r)>>1;
		if(p<=mid) inc(ls[u],ls[pre],l,mid,p,o1,o2);
		else inc(rs[u],rs[pre],mid+1,r,p,o1,o2);
	}
	int find(int t,int x)
	{
		int f=get_fa(root[t],1,n,x);
		if(x==fa[f]) return f;
		else return find(t,fa[f]);
	}
	void init(){build(root[0],1,n);return ;}
	void merge(int x,int y)
	{
		tot++;
		root[tot]=root[tot-1];
		int hx=find(tot,x),hy=find(tot,y);
//		printf("%d %d %d %d %d %d %d %d\n",x,y,get_fa(root[tot],1,n,x),get_fa(root[tot],1,n,y),fa[hx],fa[hy],dis[hx],dis[hy]);
		if(fa[hx]==fa[hy]) return;
		if(dep[hx]>dep[hy]) swap(hx,hy);
		insert(root[tot],root[tot-1],1,n,fa[hx],fa[hy]);
		inc(root[tot],root[tot],1,n,fa[hy],dep[hx],dis[hx]);
	}
	ll answer(int t,int x){return dis[find(t,x)];}
	void debug(int t){puts("");for(int i=1;i<=n;i++) printf("%d:%d %d\n",i,find(t,i),dis[find(t,i)]);}
}
void clear()
{
	memset(head,0,sizeof(head));
	cnt=0;
	DSU::clear();
}
struct road{
	int x,y,h;
	bool operator <(const road a)const{return h<a.h;}
	bool operator ==(const road a)const{return h==a.h;}
}rd[N<<1];
int get_low(int x)
{
	int l=1,r=m,ans=m;
	while(l<=r)
	{
		int u=(l+r)>>1;
		if(rd[u].h<=x) r=u-1,ans=u;
		else l=u+1;
	}
	if(rd[ans].h<=x) --ans;
	return ans;
}
int main()
{
//	freopen("return.in","r",stdin);
//	freopen("return.out","w",stdout);
	int t;
	scanf("%d",&t);
	while(t --> 0)
	{
		clear();
		scanf("%d%d",&n,&m);
		for(int i=1;i<=m;i++)
		{
			int u,v,w,h;
			scanf("%d%d%d%d",&u,&v,&w,&h);
			add(u,v,w);
			add(v,u,w);
			rd[i]=(road){u,v,h};
		}
		Dij::dij(1);
		DSU::init();
		ll las=0;
		int q,k,s;
		scanf("%d%d%d",&q,&k,&s);
		sort(rd+1,rd+m+1);
		reverse(rd+1,rd+m+1);
		for(int i=1;i<=m;i++) DSU::merge(rd[i].x,rd[i].y);
//		DSU::debug(1);
//		DSU::debug(2);
//		DSU::debug(3);
		while(q --> 0)
		{
			int v,p;
			scanf("%d%d",&v,&p);
			v=(v+k*las-1)%n+1;
			p=(p+k*las)%(s+1);
//			printf("%d %d\n",v,p);
			p=get_low(p);
			printf("%lld\n",las=DSU::answer(p,v));
		}
	}
	return 0;
}

```
