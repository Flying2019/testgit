### [链接](https://loj.ac/problem/3311)
调了一天。。。

考虑一个性质：如果我们把最短循环节相同的优秀的串看做是相同的，那么优秀的串的个数是 $O(n)$ 级别的。

再考虑一个性质：如果一个串的border大于其串长的一半，可以发现这个串的所有长度为$2*(len-border)$长度的串都是完美的。

同时很显然还有一个结论：对于一个 $len-border=a$ 的串 $s[l,r]$，对于该子串中的任意位置 $i$ ，都有 $l=a-lcs(i,i+a)+1,\ r=a+1+lcp(i+1,i+a+1)$。

所以我们可以倒推这样的串：枚举 $a$，再每隔 $a$ 枚举一次 $i$，用 $Hash$ 或是 $SA$ 找到 $lcp$，可以不漏地找出所有这样的串，时间是$O(n\ln n)$

当然，这样会把某些串重算很多次，所以需要去重，这时候用一下 unordered_map 即可。

接下来我们就找到了所有本质不同的串。把每种串的每次出现位置都记录下来，对于询问先离线处理，按右坐标排序。

可以发现每**种**串能影响询问的点是一段从1开始的区间，直接树状数组即可，每次将同种串的上一次的位置删掉，然后再插入这次的串的位置。

对于询问，当枚举的右端点等于当前询问的右端点时再树状数组上查询即可。

时间复杂度 $O(n\log^2 n)$（因为不同的串的总量是$O(n)$的）。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<unordered_map>
#include<vector>
#include<algorithm>
#define N 200010
#define base 2333
#define ull unsigned long long
#define P pair<int,int>
#define MP make_pair
#define fi first
#define se second
using namespace std;
char str[N];
ull h[N],bs[N];
ull get_hash(int l,int r){return h[r]-h[l-1]*bs[r-l+1];}
int n;
int lcp(int x,int y)
{
	int l=1,r=min(n-x+1,n-y+1),ans=0;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(get_hash(x,x+mid-1)==get_hash(y,y+mid-1)) l=mid+1,ans=mid;
		else r=mid-1;
	}
	return ans;
}
int lcs(int x,int y)
{
	int l=1,r=min(x,y),ans=0;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(get_hash(x-mid+1,x)==get_hash(y-mid+1,y)) l=mid+1,ans=mid;
		else r=mid-1;
	}
	return ans;
}
int m;
int num[N];
void insert(int x,int v){for(int i=x;i;i-=(i&(-i))) num[i]+=v;}
int answer(int x){int ans=0;for(;x<=n;x+=(x&(-x))) ans+=num[x];return ans;}
vector<P >vis[N],vpos[N];
vector<ull>pos[N],val[N];
int qid[N],l[N],r[N];
bool cmp(int x,int y){return r[x]==r[y]?l[x]<l[y]:r[x]<r[y];}
unordered_map<ull,int>mp;
int cnt,len[N],tot[N],ans[N];
int main()
{
	scanf("%d%d",&n,&m);
	scanf("%s",str+1);
	bs[0]=1;
	for(int i=1;i<=n;i++) h[i]=h[i-1]*base+(str[i]-'a'+1),bs[i]=bs[i-1]*base;
	for(int len=1;len<=n;len++)
	{
		for(int i=len;i<=n-len;i+=len)
		{
			int pre=lcs(i,i+len),nxt=lcp(i+1,i+len+1);
			if(pre==0 || pre>len || pre+nxt<len) continue;
			int L=i-pre+1,R=i+len+nxt;
			for(P x:vis[L]) if(!(len%x.fi) && x.se>=len){L=0;break;}
			if(!L) continue;
			int lth=len*2;
			for(int l=L;l+lth-1<=R;l++)
			{
				int r=l+lth-1;
				vis[l].push_back(MP(len,R-l+1));
				ull hs=get_hash(l,r);
				if(!mp[hs]) mp[hs]=++cnt,::len[cnt]=len;
				int u=mp[hs];
				pos[u].push_back(r);
				vpos[r].push_back(MP(u,pos[u].size()-1));
				tot[u]=max(tot[u],(l-L)/lth+1);
			}
		}
	}
	for(int i=1;i<=cnt;i++) val[i].resize(tot[i]*2+5);
	for(int i=1;i<=m;i++) scanf("%d%d",&l[i],&r[i]),qid[i]=i;
	sort(qid+1,qid+m+1,cmp);
	for(int rf=1,lf=1;rf<=n;rf++)
	{
		for(P x:vpos[rf])
		{
			int u=x.fi,tot=x.se,v=2;
			while(1)
			{
				if(v%2==0)
				{
					insert(val[u][v],-1);
					insert(rf-v*len[u]+1,1);
				}
				val[u][v]=rf-v*len[u]+1;
				if(tot && pos[u][tot]-pos[u][tot-1]==len[u]) --tot,++v;
				else break;
			}
		}
		for(;lf<=m && r[qid[lf]]==rf;lf++) ans[qid[lf]]=answer(l[qid[lf]]);
	}
	for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
	return 0;
}

```
