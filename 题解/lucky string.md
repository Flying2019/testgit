### [链接](https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102647/problem/B)
### 题目大意
给定 $n$ 个字符串 $s_i$，每个字符串有一个权值 $v_i$，$m$ 次询问，每次询问一个长度 $l$，定义一个字符串 $t$ 的价值为
$$\prod_{t\text{是}s_i\text{的子串}}v_i$$

问所有长度 $\leq l$ 的随机字符串的期望价值。
### 题解
看到“$n$ 个字符串”，“子串”就可以推测本题用的是广义SAM。

考虑广义SAM中的一个节点对应的状态就是该模式串 $t$ 在一些串中出现过，而且广义SAM可以保证一个子串被且仅被节点所表示。

首先对于一个给定的字符串 $t$ 需要判断是否为 $s$ 的子串，只需要沿着 $s$ SAM中的转移边按 $t$ 依次转移，当且仅当所有转移都顺利进行下 $t$ 是 $s$ 的子串。同样，这一方式也可以拓展到广义SAM上。

根据节点的意义可以发现，每个广义SAM中的节点 $u$ 可以表示一段字符串中一段长度为 $(len_{fa},len_u]$ 的后缀。反过来说，对于任意长度为 $(len_fa,len_u]$ 的字符串，**有且仅有一个**字符串的转移终止在节点 $u$ 上。

所以，如果我们算出了所有广义SAM的节点的价值 $val_i$（即终止于该节点的字符串的价值），那么对于询问 $l$ ，期望价值就是
$$\frac{\sum_{i\in SAM}{\sum_{j=1}^{l} [\ j\in(len_{fa_i},len_i]\ ]\ val_i}}{\sum_{i=1}^{l}26^i}$$
很显然，上述公式可以通过差分解决。即对于节点 $i$，在 $sum[len[fa[i]]+1]$ 上 $+val[i]$，在 $sum[len[i]+1]$ 上 $-val[i]$，最后前缀和两次即可。

接下来考虑如何计算价值 $val_i$。可以发现这等同于求
$$\prod_{i\text{能到达}s_j\text{的节点}}v_j$$
可以发现，这相当于 $i$ 是某个 $s_i$ 的节点在parent树上的祖先。

所以，对于每次插入 $s_i$ 的一个节点，直接跳祖先 $\times v_i$ 即可。为了防止记重，可以开一个数组表示当前节点是否被更新过。如果被更新了就不必往上跳了。

看似复杂度很假。但是由于这些节点本来就应该属于 $s_i$ 的SAM当中的，根据广义 $SAM$ 的复杂度证明其实是可行的。

所以只需按上述方式统计答案即可，复杂度 $O(26n)$。
