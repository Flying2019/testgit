### [链接](https://loj.ac/problem/2721)
首先假设我们能完成每个游戏，那么每个游戏用的刀是固定的。我们可以用STL预处理出这个值。

可以发现，对于每一个游戏，本质就是一个同余方程 $b_ix\equiv a_i\pmod {p_i}$，其中要求 $b_ix\geq a_i$。

首先考虑前面那个式子。这是一个很经典的excrt的变形。

具体来说，一般情况下的excrt只能处理 $b_i=1$。由于 $p_i$ 不一定是质数，所以我们不能直接乘上逆元，但是我们可以通过exgcd求解。

考虑这样可以处理出前面的一个最小正整数解。考虑处理后面的式子。

可以发现我们最后的同余方程也是 $x\equiv a\pmod {m}$ 的形式，那么对于通解，加上若干次 $m$ 仍然成立。直接处理即可。

复杂度 $O(n\log n)$。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<set>
#define N 100010
#define ll long long
using namespace std;
multiset<ll>s;
ll ksc(ll a,ll b,ll mod)
{
    ll r=0;
    for(;b;b>>=1)
    {
        if(b&1) r=(r+a)%mod;
        a=(a+a)%mod;
    }
    return r;
}
ll exgcd(ll a,ll b,ll &x,ll &y)
{
    if(!b){x=1,y=0;return a;}
    ll g=exgcd(b,a%b,y,x);
    y=y-(a/b)*x;
    return g;
}
ll pa[N],pb[N],p[N];//ax%p=b%p
ll excrt(int n,ll lst)
{
    ll ans=0,mod=1;
    for(int i=1;i<=n;i++)
    {
        ll a=ksc(pb[i],mod,p[i]),b=p[i],c=(pa[i]-ksc(pb[i],ans,p[i])+p[i])%p[i],x,y;
        ll g=exgcd(a,b,x,y);
        x=(x%b+b)%b;
        if(c%g) return -1;
        b/=g,c/=g;
        ll m1=mod*b;
        ans=(ans+ksc(c,x,b)*mod%m1)%m1;
        mod=m1;
    }
    if(ans<lst) ans+=((lst-ans-1)/mod+1)*mod;
    return ans;
}
ll ad[N];
int main()
{
    int t;
    scanf("%d",&t);
    while(t --> 0)
    {
        s.clear();
        int n,m;
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++) scanf("%lld",&pa[i]);
        for(int i=1;i<=n;i++) scanf("%lld",&p[i]);
        for(int i=1;i<=n;i++) scanf("%lld",&ad[i]);
        for(int i=1;i<=m;i++)
        {
            ll x;
            scanf("%lld",&x);
            s.insert(x);
        }
        ll lst=0;
        for(int i=1;i<=n;i++)
        {
            auto p=s.upper_bound(pa[i]);
            if(p!=s.begin()) --p;
            pb[i]=*p;
            s.erase(p),s.insert(ad[i]);
        }
        for(int i=1;i<=n;i++) lst=max(lst,(pa[i]-1)/pb[i]+1);
        printf("%lld\n",excrt(n,lst));
    }
    return 0;
}
```
