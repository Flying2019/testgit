#### [题目链接](https://www.luogu.com.cn/problem/P3703)
## 题目大意
有三种操作，

1. 把点 $x$ 到根节点的路径上所有的点染上一种没有用过的新颜色。
2. 求 $x$ 到 $y$ 的路径的上的不同颜色数。
3. 在以$x$为根的子树中选择一个点，使得这个点到根节点的路径的不同颜色数最大，求最大权值。

## 解题思路
可以发现修改操作的一个性质：每种颜色的节点一定会形成一条链。

利用LCT的性质，考虑一次access实际是将某个点与根的路径打通，对应操作1，而一个点到根路径上虚边的数量+1对应它到根的颜色数，这个颜色数在splay的时候维护一下就行了。

用$dep[x]$表示$x$到根的颜色数，可以发现操作2的答案是$dep[x]+dep[y]-2*dep[lca(x,y)]+1$。

考虑操作3，其实就是子树求$dep$最大值，套一个树剖就好了。

由于LCT只是用于提取路径，所以没有make_root操作，不用打翻转标记。
## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#define N 100010
using namespace std;
int nxt[N<<1],to[N<<1],head[N],cnt;
void add(int u,int v)
{
	nxt[++cnt]=head[u];
	to[cnt]=v;
	head[u]=cnt;
}
int siz[N],dep[N],id[N],nid[N],n,tot;
struct seg_tree{
	int val[N<<2],tag[N<<2];
	void push_down(int u)
	{
		if(!tag[u]) return;
		val[u<<1]+=tag[u];
		val[u<<1|1]+=tag[u];
		tag[u<<1]+=tag[u];
		tag[u<<1|1]+=tag[u];
		tag[u]=0;
	}
	void change(int u,int l,int r,int L,int R,int v)
	{
		if(L<=l && r<=R){val[u]+=v,tag[u]+=v;return;}
		int mid=(l+r)>>1;
		push_down(u);
		if(L<=mid) change(u<<1,l,mid,L,R,v);
		if(R>mid) change(u<<1|1,mid+1,r,L,R,v);
		val[u]=max(val[u<<1],val[u<<1|1]);
	}
	void build(int u,int l,int r)
	{
		if(l==r){val[u]=dep[nid[l]];return;}
		int mid=(l+r)>>1;
		build(u<<1,l,mid);
		build(u<<1|1,mid+1,r);
		val[u]=max(val[u<<1],val[u<<1|1]);
    }
	int answer(int u,int l,int r,int L,int R)
	{
		if(L>r || R<l) return 0;
		if(L<=l && r<=R) return val[u];
		push_down(u);
		int mid=(l+r)>>1;
		return max(answer(u<<1,l,mid,L,R),answer(u<<1|1,mid+1,r,L,R));
	}
}tr;
struct LCT{
	int fa[N],ch[N][2];
//	bool tag[N];
	bool not_root(int u){return ch[fa[u]][0]==u || ch[fa[u]][1]==u;}
//	void set_tag(int u){swap(ch[u][0],ch[u][1]);tag[u]^=1;}
//	void push_down(int u)
//	{
//		if(!tag[u]) return;
//		set_tag(ch[u][0]);
//		set_tag(ch[u][1]);
//		tag[u]=false;
//	}
	void rotate(int u)
	{
		int f=fa[u],ff=fa[f],k=ch[f][1]==u,v=ch[u][!k];
		if(not_root(f)) ch[ff][ch[ff][1]==f]=u;
		ch[u][!k]=f;
		ch[f][k]=v;
		if(v) fa[v]=f;
		fa[f]=u;
		fa[u]=ff;
	}
//	int ton[N];
//	void push_all(int u)
//	{
//		int top=0;
//		ton[++top]=u;
//		while(not_root(u)) ton[++top]=fa[u],u=fa[u];
//		while(top) push_down(ton[top--]);
//	}
	void splay(int u)
	{
//		push_all(u);
		while(not_root(u))
		{
			int f=fa[u],ff=fa[f];
			if(not_root(f)) rotate((ch[f][0]==u)^(ch[ff][0]==f)?u:f);
			rotate(u);
		}
	}
	int find_root(int u)
	{
		while(ch[u][0]) u=ch[u][0];
		return u;
	}
	void access(int u)
	{
		for(int x=0;u;x=u,u=fa[u])
		{
			splay(u);
			if(ch[u][1])
			{
				int v=find_root(ch[u][1]);
				tr.change(1,1,n,id[v],id[v]+siz[v]-1,1);
			}
			ch[u][1]=x;
			if(x)
			{
				int v=find_root(x);
				tr.change(1,1,n,id[v],id[v]+siz[v]-1,-1);
			}
		}
	}
}lct;
int son[N],fa[N],top[N];
void dfs1(int u,int f)
{
	lct.fa[u]=fa[u]=f;
	dep[u]=dep[f]+1;
	siz[u]=1;
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==f)continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[son[u]]<siz[v]) son[u]=v;
	}
}
void dfs2(int u,int topp)
{
	id[u]=++tot;
	nid[tot]=u;
	top[u]=topp;
	if(son[u]) dfs2(son[u],topp);
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v!=fa[u] && v!=son[u]) dfs2(v,v);
	}
}
int lca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	return x;
}

int main()
{
	int m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);
		add(v,u);
	}
	dfs1(1,0);
	dfs2(1,1);
	tr.build(1,1,n);
	for(int i=1;i<=m;i++)
	{
		int opt,x,y;
		scanf("%d%d",&opt,&x);
		if(opt==1) lct.access(x);
		else if(opt==2)
		{
			scanf("%d",&y);
			int l=lca(x,y);
			printf("%d\n",tr.answer(1,1,n,id[x],id[x])+tr.answer(1,1,n,id[y],id[y])-2*tr.answer(1,1,n,id[l],id[l])+1);
		}
		else printf("%d\n",tr.answer(1,1,n,id[x],id[x]+siz[x]-1));
	}
	return 0;
}
```
