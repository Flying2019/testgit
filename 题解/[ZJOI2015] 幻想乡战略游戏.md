### [链接](https://www.luogu.com.cn/problem/P3345)
显然可以发现这道题是动态点分治――――~~什么？你连动态点分治都不会？~~（雾

其实可以直接用树剖。考虑题目本质要求的就是带权重心，这个东西直接链加，查询的时候类似于线段树上二分，然后就好了。

复杂度 $O(n\log^2 n)$
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
#define N 100010
using namespace std;
int nxt[N<<1],to[N<<1],head[N],cnt;
int w[N<<1];
void add(int u,int v,int w1)
{
	nxt[++cnt]=head[u];
	to[cnt]=v;
	w[cnt]=w1;
	head[u]=cnt;
}
int fa[N],siz[N],dep[N],son[N],dis[N];
int top[N],id[N],nid[N],wid[N],tot,n,m;
void dfs1(int u)
{
	siz[u]=1;
	dep[u]=dep[fa[u]]+1;
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==fa[u]) continue;
		fa[v]=u;
		dis[v]=dis[u]+w[i];
		dfs1(v);
		if(siz[son[u]]<siz[v]) son[u]=v;
		siz[u]+=siz[v];
	}
}
void dfs2(int u,int topp)
{
	top[u]=topp;
	id[u]=++tot;
	nid[tot]= u;
	wid[tot]=dis[u]-dis[fa[u]];
	if(son[u]) dfs2(son[u],topp);
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v!=fa[u] && v!=son[u])dfs2(v,v);
	}
}
int sz[N<<2],tag[N<<2];
ll sum[N<<2],val[N<<2];
void build(int u,int l,int r)
{
	if(l==r){val[u]=wid[l];return;}
	int mid=(l+r)>>1;
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
	val[u]=val[u<<1]+val[u<<1|1];
}
void set_tag(int u,int v){sz[u]+=v;tag[u]+=v;sum[u]+=1ll*v*val[u];}
void push_down(int u)
{
	if(!tag[u]) return;
	set_tag(u<<1,tag[u]),set_tag(u<<1|1,tag[u]);
	tag[u]=0;
}
void update(int u)
{
	sz[u]=max(sz[u<<1],sz[u<<1|1]);
	sum[u]=sum[u<<1]+sum[u<<1|1];
}
void insert(int u,int l,int r,int L,int R,ll v)
{
	if(L<=l && r<=R){set_tag(u,v);return;}
	int mid=(l+r)>>1;
	push_down(u);
	if(L<=mid) insert(u<<1,l,mid,L,R,v);
	if(R>mid) insert(u<<1|1,mid+1,r,L,R,v);
	update(u);
}
ll answer(int u,int l,int r,int L,int R)
{
	if(L<=l && r<=R) return sum[u];
	push_down(u);
	int mid=(l+r)>>1;
	ll v=0;
	if(L<=mid) v+=answer(u<<1,l,mid,L,R);
	if(R>mid) v+=answer(u<<1|1,mid+1,r,L,R);
	return v;
}
int get_weight(void)
{
	int u=1,l=1,r=n;
	while(l<r)
	{
		push_down(u);
		int mid=(l+r)>>1;
		if(sz[u<<1|1]*2>=sz[1]) l=mid+1,u=u<<1|1;
		else r=mid,u=u<<1;
	}
	return nid[l];
}
void add(int x,int v)
{
	for(;top[x]!=1;x=fa[top[x]]) insert(1,1,n,id[top[x]],id[x],v);
	insert(1,1,n,1,id[x],v);
}
ll answer(int x)
{
	ll res=0;
	for(;top[x]!=1;x=fa[top[x]]) res+=answer(1,1,n,id[top[x]],id[x]);
	return res+answer(1,1,n,1,id[x]);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w);
		add(v,u,w);
	}
	dfs1(1);
	dfs2(1,1);
	build(1,1,n);
	ll s1=0,s2=0;
	while(m --> 0)
	{
		int x,v;
		scanf("%d%d",&x,&v);
		s1+=v;
		s2+=1ll*dis[x]*v;
		add(x,v);
		int p=get_weight();
		printf("%lld\n",s2+s1*dis[p]-2*answer(p));
	}
	return 0;
}

```
