### [链接](https://www.luogu.com.cn/problem/P4542)
看到 $n\leq 150,m\leq 20000$ 的范围，第一下想到的肯定是费用流。

考虑如何建流。首先显然可以用floyd加一些变形算出两点之间经过合法路径的距离。

因为这时候点之间经过的先后顺序已经不重要了，那么接下来题目就变成：已知任意两点之间的距离，用 $k$ 条链（不一定是简单链）起点为0覆盖每个节点恰好一次，求链长和的最小值。

显然应该拆点。显然给0灌 $k$ 的流，再从每个节点拿 $1$ 的流。但是这样没法处理链。

可以发现本质上我们只需要一个节点被“到达”过即可，而这个 $i->T$ 的流不能少。所以我们考虑将这个流“还”回去，即 $S->i$ 灌1的流。

可以发现如果一个点是链的终点，那么这条 $S->i$ 的边就无效，这样不会对答案造成影响。

由于每个点 $i->T$ 的流一定会流满，所以也不会出现多流的情况。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#define C 210
#define N 80010
#define ll long long
using namespace std;
struct node{
	int nxt,to,f;
	ll w;
}road[N];
int head[N],cnt=1;
void add(int u,int v,int m,ll w)
{
	road[++cnt]=(node){head[u],v,m,w};
	head[u]=cnt;
	road[++cnt]=(node){head[v],u,0,-w};
	head[v]=cnt;
}
int pre[N],bef[N],flow[N];
ll dis[N];
bool in[N];
queue<int>q;
bool spfa(int s,int t)
{
	memset(dis,127,sizeof(dis));
	memset(flow,127,sizeof(flow));
	memset(in,0,sizeof(in));
	while(!q.empty())q.pop();
	q.push(s);
	dis[s]=0;
	in[s]=true;
	pre[t]=-1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		in[u]=false;
		for(int i=head[u];i;i=road[i].nxt)
		{
			int v=road[i].to;
			if(road[i].f>0 && dis[v]>dis[u]+road[i].w)
			{
				dis[v]=dis[u]+road[i].w;
				pre[v]=u;
				bef[v]=i;
				flow[v]=min(flow[u],road[i].f);
				if(!in[v])
				{
					in[v]=true;
					q.push(v);
				}
			}
		}
	}
	return pre[t]!=-1;
}
ll MCMF(int s,int t)
{
	ll maxf=0,minw=0;
	while(spfa(s,t))
	{
		int u=t;
		maxf+=flow[t];
		minw+=flow[t]*dis[t];
		while(u!=s)
		{
			road[bef[u]].f-=flow[t];
			road[bef[u]^1].f+=flow[t];
			u=pre[u];
		}
	}
	return minw;
}
int n,m;
ll f[C][C];
int main()
{
	int k;
	scanf("%d%d%d",&n,&m,&k);
	++n;
	int s=n*2+1,t=s+1;
	memset(f,60,sizeof(f));
	for(int i=1;i<=n;i++) f[i][i]=0; 
	for(int i=1;i<=m;i++)
	{
		int u,v;
		ll w;
		scanf("%d%d%lld",&u,&v,&w);
		++u,++v;
		f[u][v]=f[v][u]=min(f[v][u],w);
	}
	for(int k=1;k<=n;k++)
		for(int j=1;j<=n;j++)
			for(int i=1;i<=n;i++)
			if(k<=i || k<=j) f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
	for(int i=1;i<=n;i++)
	{
		if(i==1) add(s,i*2-1,k,0);
		else add(s,i*2-1,1,0);
		add(i*2,t,1,0);
		for(int j=i+1;j<=n;j++) add(i*2-1,j*2,1,f[i][j]);
	}
	printf("%lld\n",MCMF(s,t));
	return 0;
}

```
