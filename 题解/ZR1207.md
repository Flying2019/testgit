可以采用线段树套trie实现区间修改和查询，但会导致空间不够。考虑只对需要修改的点进行标记，可以减少空间。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<set>
#define N 200010
#define D 30
#define M N*(D+1)
#define inf 1000000000
using namespace std;
int fa[N],siz[N],son[N];
int a[N],dep[N],top[N],rt[N],cnt;
int num[M],id[M],ch[M][2],nid;
set<int>s[N];
void update(int x){num[x]=min(ch[x][0]?num[ch[x][0]]:inf,ch[x][1]?num[ch[x][1]]:inf);}
void insert(int l,int u,int v,int d)
{
	if(l<0)
	{
		if(!id[u]) id[u]=++nid;
		s[id[u]].insert(d);
		num[u]=*s[id[u]].begin();
		return;
	}
	int c=(v>>l)&1;
	if(!ch[u][c]) ch[u][c]=++cnt;
	insert(l-1,ch[u][c],v,d);
	update(u);
}
void erase(int l,int u,int v,int d)
{
	if(l<0)
	{
		s[id[u]].erase(d);
		if(s[id[u]].empty()) num[u]=inf;
		else num[u]=*s[id[u]].begin();
		return;
	}
	int c=(v>>l)&1;
	erase(l-1,ch[u][c],v,d);
	update(u);
}
int answer(int u,int v,int d)
{
	int ans=0;
	for(int i=D;i>=0;i--)
	{
		int c=(v>>i)&1;
		if(ch[u][!c] && num[ch[u][!c]]<=d) u=ch[u][!c],ans|=1<<i;
		else u=ch[u][c];
	}
	return ans;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=2;i<=n;i++) scanf("%d",&fa[i]),dep[i]=dep[fa[i]]+1;
	for(int u=n;u>=2;u--)
	{
		siz[u]++;
		siz[fa[u]]+=siz[u];
		if(siz[u]>siz[son[fa[u]]]) son[fa[u]]=u;
	}
	for(int i=1;i<=n;i++)
	{
		top[i]=son[fa[i]]==i?top[fa[i]]:i;
		if(top[i]==i) rt[top[i]]=++cnt;
		insert(D,rt[top[i]],a[i],dep[i]);
	}
	while(m --> 0)
	{
		int opt,u,v;
		scanf("%d%d",&opt,&u);
		if(opt)
		{
			int ans=0;
			for(int p=u;p;p=fa[top[p]]) ans=max(ans,answer(rt[top[p]],a[u],dep[p]));
			printf("%d\n",ans);
		}
		else
		{
			scanf("%d",&v);
			erase(D,rt[top[u]],a[u],dep[u]);
			a[u]=v;
			insert(D,rt[top[u]],a[u],dep[u]);
		}
	}
	return 0;
}
```
反思：set的空间特别大。。即使不存任何东西开1000000也会MLE
