### [链接](https://www.luogu.com.cn/problem/P2371)
同余最短路模板题。

具体来说，这类题有一个共同特点：$n\times a$ 特别小（要么是 $n$ 特别小，要么是 $a$ 特别小），且值域巨大。

那么具体怎么实现？考虑魔改背包中的转移边 $f_{x}\rightarrow f_{x+a_i}$。具体来说，我们找到一个值 $b\in {a_i}$，然后将所有边连到 $[0,b)$ 区间内，权值等于 $a_i$。可以发现，这样的图中如果 $u$ 可以在 $t_u$ 时刻内被到达，那么对于背包 $V>t_u+bx$，$u+bx,(x\geq 0)$ 也可以被到达。因为图中我们缩去一条转移边 $f_x\rightarrow f_{x+b}$，这也正是同余最短路成立的必要条件，当然这里 $b$ 取 $\min\{a_i\}$ 最优。

然后对于此题，我们简单差分一下即可。复杂度 $O(nb)$。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define N 500010
#define ll long long
using namespace std;
ll dis[N];
int a[N];
queue<int>q;
int main()
{
    int n,m=N;ll l,r;
    scanf("%d%lld%lld",&n,&l,&r);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]),m=min(m,a[i]);
    memset(dis,60,sizeof(dis));
    dis[0]=0;q.push(0);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=1;i<=n;i++)
        if(dis[(u+a[i])%m]>dis[u]+a[i]) dis[(u+a[i])%m]=dis[u]+a[i],q.push((u+a[i])%m);
    }
    ll ans=0;
    for(int i=0;i<m;i++)
    if(dis[i]<=r)
    {
        ll xl=max((l-dis[i]+m-1)/m,0ll),xr=(r-dis[i])/m;
        ans+=xr-xl+1;
    }
    printf("%lld\n",ans);
    return 0;
}
```
