计算几何，暴力求半平面交，然后暴力处理。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define db double
#define P pair<db,db>
#define MP make_pair
#define fi first
#define se second
#define N 410
using namespace std;
const double pi=acos(-1),chg=pi/180;
db d[N],b[N];
int a[N];
P v[N];
int main()
{
	int n,r;
	scanf("%d%d",&n,&r);
	for(int i=0;i<360;i++) d[i]=r;
	for(int i=1;i<=n;i++)
	{
		int x;
		db h;
		scanf("%d%lf",&x,&h);
		d[x]=min(d[x],h);
	}
	n=0;
	for(int i=0;i<360;i++)
	if(d[i]<r) a[++n]=i,b[n]=d[i];
	db ans=0,x=0,y=0,p=0,al,be;
	for(int i=1;i<=n;i++)
	{
		y=sqrt(r*r-b[i]*b[i]);
		x=-y;
		for(int j=1;j<=n;j++)
		if(i!=j)
		{
			int res=0;
			res=a[j]-a[i];
			if(res<0) res+=360;
			if(res==180) continue;
			if(res==90) p=b[j];
			else if(res==270) p=-b[j];
			else p=b[j]*sin(res*chg)-1.0/tan(res*chg)*(b[i]-b[j]*cos(res*chg));
			if(res<180) y=min(y,p);
			else x=max(x,p);
			if(x>y) break;
		}
		if(x<y) ans+=y-x;
	}
	printf("%.10lf ",ans);
	ans=0;
	for(int i=1;i<=n;i++)
	{
		x=a[i]*chg;
		y=acos(b[i]/r);
		v[i]=MP(x-y,x+y);
	}
	sort(v+1,v+n+1);
	al=v[1].fi;
	be=v[1].se;
	for(int i=2;i<=n;i++)
	{
		if(v[i].fi<be) be=max(be,v[i].se);
		else
		{
			ans+=be-al;
			al=v[i].fi;
			be=v[i].se;
		}
	}
	if(v[1].fi+2*pi<be) be=v[1].fi+2*pi;
	ans=2*pi-ans-be+al;
	printf("%.10lf\n",ans*r);
	return 0;
}
```
反思：double千万不要用==判断
