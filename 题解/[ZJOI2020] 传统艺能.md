### [链接](https://loj.ac/problem/3312)
考虑对每个节点单独计算贡献。

可以发现每次操作对某个节点只有5种情况：覆盖自己，覆盖父亲，覆盖兄弟，与自己相交（不覆盖），无关。

对于五种情况分别分类讨论，可以得出$O(nk)$的转移方程。

然后可以发现$f[u][0/1]$(该节点有/无tag的概率)与5种情况的转移是线性递推的关系，可以用矩阵加速。

利用矩阵快速幂可以做到$O(n\log k)$
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
#define N 200010
#define mod 998244353
using namespace std;
int ksm(int a,int b=mod-2)
{
	int ans=1;
	for(;b;b>>=1)
	{
		if(b&1) ans=1ll*ans*a%mod;
		a=1ll*a*a%mod;
	}
	return ans;
}
struct matrix{
	int num[3][3];
	int* operator [](int c){return num[c];}
	matrix(int a=0){memset(num,0,sizeof(num));num[0][0]=num[1][1]=num[2][2]=a;}
};
matrix operator *(matrix a,matrix b)
{
	matrix c;
	for(int i=0;i<3;i++)
		for(int j=0;j<3;j++)
			c[i][j]=(1ll*a[i][0]*b[0][j]+1ll*a[i][1]*b[1][j]+1ll*a[i][2]*b[2][j])%mod;
	return c;
}
matrix ksm(matrix a,int b)
{
	matrix c(1);
	for(;b;b>>=1)
	{
		if(b&1) c=c*a;
		a=a*a;
	}
	return c;
}
int ans=0,n,k;
inline ll C2(int a){return (1ll*a*(a-1)/2)%mod;}
inline ll in_p(int l,int r){return (1ll*l*(n-r+1))%mod;}
void dfs(int l,int r,int fl,int fr)
{
	int f1=(C2(n+1)-in_p(l,r)-C2(l)-C2(n-r+1)+4ll*mod)%mod,
	f2=(fl==l?C2(n-r+1)-C2(n-fr+1)+mod :
	(fr==r?C2(l)-C2(fl)+mod :0))%mod,
	f3=(in_p(l,r)-in_p(fl,fr)+mod)%mod,
	f4=in_p(fl,fr)%mod,
	f5=(C2(n+1)-f1-f2-f3-f4+4ll*mod)%mod;
	matrix a;
	a[0][0]=(f4+f5)%mod;
	a[1][0]=f2;
	a[1][1]=(f2+f5)%mod;
	a[2][0]=f3;
	a[2][1]=(f3+f4)%mod;
	a[2][2]=C2(n+1)%mod;
	ans=(ans+ksm(a,k)[2][0])%mod;
	if(l==r) return;
	int mid=(l+r)>>1;
	scanf("%d",&mid);
	dfs(l,mid,l,r);
	dfs(mid+1,r,l,r);
}
int main()
{
	scanf("%d%d",&n,&k);
	dfs(1,n,0,0);
	printf("%lld\n",1ll*ans*ksm(ksm(C2(n+1),k))%mod);
	return 0;
}
```
