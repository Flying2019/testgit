考虑一个点能够**被**支配的点的范围一定是一条链，而这条链的链顶就是能支配它并且离它最远的点。

所以考虑利用二分找到这个点，可以发现这是一段链~~于是就直接树剖~~直接树上差分，在链底加，链顶减，然后自底向上Dfs即可。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 200010
#define ll long long
using namespace std;
int val[N],nxt[N<<1],to[N<<1],head[N],cnt;
ll q[N],len[N<<1],dep[N];
void add(int u,int v,int w)
{
	nxt[++cnt]=head[u];
	to[cnt]=v;
	len[cnt]=w;
	head[u]=cnt;
}
ll f[N],a[N];
int id[N],tot;
void dfs(int u,int pre)
{
	f[u]=1;
	ll d=dep[u]-a[u];
	int p=lower_bound(q+1,q+tot+1,d)-q-1;
	q[++tot]=dep[u];
	id[tot]=u;
	if(p>=0) f[id[p]]--;
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		dep[v]=dep[u]+len[i];
		dfs(v,u);
		f[u]+=f[v];
	}
	--tot;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=2;i<=n;i++)
	{
		int p,w;
		scanf("%d%d",&p,&w);
		add(p,i,w);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++) printf("%d ",f[i]-1);
	return 0;
}

```
