#### [题目链接](https://www.luogu.com.cn/problem/P4219)
## 题目大意
有$n$个点，一开始没有边。动态加边，保证加的边两端的点不连通。查询一条边两端的连通块大小乘积。
## 解题思路
动态加边，考虑用LCT维护。

可以用一个新的变量sz来存储一个点所在子树中虚边连接的节点大小。

考虑一次access操作中一个点sz变化当且仅当其在access的路径上。所以只需要在access的时候顺便修改一下即可。

查询操作可以看成将$(x,y)$的路径split出来，考虑因为此时$(x,y)$是x和y唯一的实边，所以答案就是$(sz[x]+1)*(sz[y]+1)$。
## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 100010
#define ll long long
using namespace std;
//int nxt[N<<1],to[N<<1],head[N];
int root[N];
int num[N];
struct LCT{
	int val[N],sz[N],ch[N][2],tag[N],fa[N],cnt;
	bool not_root(int u){return ch[fa[u]][0]==u || ch[fa[u]][1]==u;}
	void set_tag(int u){swap(ch[u][0],ch[u][1]);tag[u]^=1;}
	void update(int u){val[u]=val[ch[u][0]]+val[ch[u][1]]+sz[u]+1;}
	void push_down(int u)
	{
		if(!tag[u]) return;
		tag[u]=false;
		if(ch[u][0]) set_tag(ch[u][0]);
		if(ch[u][1]) set_tag(ch[u][1]);
	}
	void rotate(int u)
	{
		int f=fa[u],ff=fa[f];
		int k=ch[f][1]==u,v=ch[u][!k];
		if(not_root(f)) ch[ff][ch[ff][1]==f]=u;
		ch[u][!k]=f;
		ch[f][k]=v;
		if(v) fa[v]=f;
		fa[f]=u;
		fa[u]=ff;
		update(f);
		update(u);
	}
	int ton[N],top;
	void push_all(int u)
	{
		top=0;
		while(not_root(u)) ton[++top]=u,u=fa[u];
		ton[++top]=u;
		while(top) push_down(ton[top--]);
	}
	void splay(int x)
	{
		push_all(x);
		while(not_root(x))
		{
			int f=fa[x],ff=fa[f];
			if(not_root(f)) rotate((ch[ff][0]==f)^(ch[f][0]==x)?x:f);
			rotate(x);
		}
		update(x);
	}
	void access(int x)
	{
		for(int y=0;x;y=x,x=fa[x])
		{
			splay(x);
			sz[x]+=val[ch[x][1]];
			ch[x][1]=y;
			sz[x]-=val[y];
			update(x);
		}
	}
	void make_root(int x)
	{
		access(x);
		splay(x);
		set_tag(x);
	}
	void split(int x,int y)
	{
		make_root(x);
		access(y);
		splay(y);
	}
	int find_root(int u)
	{
		access(u);
		splay(u);
		while(ch[u][0]) push_down(u),u=ch[u][0];
		splay(u);
		return u;
	}
	void link(int u,int v)
	{
		split(u,v);
		fa[u]=v;
		sz[v]+=val[u];
		update(v);
	}
}t;
char s[2];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) t.val[i]=1;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%s%d%d",s,&x,&y);
		if(s[0]=='A') t.link(x,y);
		else
		{
			t.split(x,y);
			printf("%lld\n",1ll*(t.sz[x]+1)*(t.sz[y]+1));
		}
	}
	return 0;
}
```
