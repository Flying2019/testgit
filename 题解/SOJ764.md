贪心,发现可以用线段树优化。线段树合并。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 200010
#define M N*20
using namespace std;
int ls[M],rs[M],rt[N],num[M],cnt;
int f[N];
int find(int x){return f[x]==x?f[x]:(f[x]=find(f[x]));}
void insert(int &u,int l,int r,int p)
{
	if(!u) u=++cnt;
	if(l==r){num[u]++;return;}
	int mid=(l+r)>>1;
	if(p<=mid) insert(ls[u],l,mid,p);
	else insert(rs[u],mid+1,r,p);
	num[u]=num[ls[u]]+num[rs[u]];
}
long long ans,res[N];
int merge(int x,int y)
{
	if(!x || !y) return x+y;
	ans=ans+1ll*num[rs[x]]*num[ls[y]];
	ls[x]=merge(ls[x],ls[y]);
	rs[x]=merge(rs[x],rs[y]);
	num[x]=num[ls[x]]+num[rs[x]];
	return x;
}
int a[N],b[N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),insert(rt[i],1,n,a[i]);
	for(int i=1;i<n;i++) scanf("%d",&b[i]);
	for(int i=1;i<=n;i++) f[i]=i;
	for(int i=n-1;i;i--)
	{
		int hx=find(b[i]),hy=find(b[i]+1);
		ans=0;
		rt[hy]=merge(rt[hx],rt[hy]);
		f[hx]=hy;
		res[i]=ans;
	}
	for(int i=0;i<n;i++) res[i+1]=res[i+1]+res[i],printf("%lld\n",res[i]);
	return 0;
}

```
