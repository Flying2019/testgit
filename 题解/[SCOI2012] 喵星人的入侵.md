### [链接](https://www.luogu.com.cn/problem/P2337)
神仙题插头dp。。。

首先贪心，可以发现肯定只会给喵星人留一条路径，其他路径堵死肯定不比不堵劣。所以本质上就是一条从S到T的路径。

所以考虑插头dp，这里要加入一种新的插头，即和S直接相连的插头，因为这种插头只会有一个，要特殊考虑。其余左右插头的处理和模板题类似。

再考虑计算贡献。考虑处理轮廓线时将其上层的格子的状态也要记录，即是否为路径或炮塔。转移时如果当前格子为路径就要加上其周围炮塔的贡献，为炮塔就要加上其周围路径的贡献。

可以发现由于我们只转移左上的状态，所以一对路径和炮塔的贡献只会被计算一次。

然后只要对 **28** 种情况进行分类讨论即可。复杂度 $O(\text{能过})$。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#define N 6
#define C 24
#define M 1<<C
#define P 500010
#define int long long
using namespace std;
int f[2][1<<24],h[2][3][1<<24],cnt[2],u;
int head[P+3],nxt[M];
void insert(int s1,int s2,int s3,int v)
{
	int k=((((1ll*s1<<16)|s2)<<4)|s3)%P+1;
	for(int i=head[k];i;i=nxt[i])
	if(h[u][0][i]==s1 && h[u][1][i]==s2 && h[u][2][i]==s3){f[u][i]=max(f[u][i],v); return;}
	int p=++cnt[u];
	f[u][p]=v;
	h[u][0][p]=s1,h[u][1][p]=s2,h[u][2][p]=s3;
	nxt[p]=head[k];
	head[k]=p;
}
inline int getst(int sta,int p){return (sta>>(p<<1))&3;}
inline int del(int sta,int p){return sta^(getst(sta,p)<<(p<<1));}
inline int chg(int sta,int p,int v){return del(sta,p)^(v<<(p<<1));}
inline int rem(int sta,int p,int v){return sta^(v<<(p<<1));}
int find_l(int sta,int p,int v)
{
	int t=1;
	for(;p>=0;p--)
	{
		int s=getst(sta,p);
		if(s==2) ++t;
		if(s==1) --t;
		if(!t) return chg(sta,p,v);
	}
//	throw;
}
int find_r(int sta,int p,int v)
{
	int t=1;
	for(;p<=C;p++)
	{
		int s=getst(sta,p);
		if(s==1) ++t;
		if(s==2) --t;
		if(!t) return chg(sta,p,v);
	}
//	throw;
}
char str[C+2][C+2],mcp[C+2][C+2];
signed main()
{
	int n,m,k;
	scanf("%lld%lld%lld",&n,&m,&k);
	for(int i=0;i<n;i++) scanf("%s",str[i]);
	if(n<m)
	{
		memcpy(mcp,str,sizeof(mcp));
		for(int i=0;i<n;i++)
			for(int j=0;j<m;j++) str[j][i]=mcp[i][j];
		swap(n,m);
	}
	cnt[0]=1;
	for(int i=0;i<n;i++)
	{
		for(int j=1;j<=cnt[u];j++) h[u][0][j]<<=2;
		for(int j=1;j<=cnt[u];j++) h[u][1][j]=del(h[u][1][j],m+1)<<2;
		for(int j=0;j<m;j++)
		{
			int p=u;
			u=!u;
			cnt[u]=0;
			memset(head,0,sizeof(head));
			for(int _=1;_<=cnt[p];_++)
			{
				int s1=h[p][0][_],s2=h[p][1][_],s3=h[p][2][_],v=f[p][_];
				if(s1>=1<<((m+1)<<1)) continue;
				int p1=getst(s1,j),p2=getst(s1,j+1);
				int fr=getst(s2,j),ur=getst(s2,j+1);
				int fu=getst(s2,j+2),ul=getst(s2,j+3);
				int vl=(fr==1)+(ur==1)+(fu==1)+(ul==1),vr=(fr==3)+(ur==3)+(fu==3)+(ul==3);
				int s=del(del(s1,j),j+1);
				if((!p1 && fr==1) || (!p2 && fu==1))
				{
					if(p1 || p2) continue;
					insert(s,del(s2,j+1),s3,v);
					if(s3<k && str[i][j]=='.') insert(s,chg(s2,j+1,3),s3+1,v+vl);
				}
				else if(str[i][j]=='#') {if(!p1 && !p2) insert(s,del(s2,j+1),s3,v);}
				else if(str[i][j]=='.')
				{
					if(!p1 && !p2)
					{
						if(s3<k) insert(s,chg(s2,j+1,3),s3+1,v+vl);
						insert(rem(rem(s,j,1),j+1,2),chg(s2,j+1,1),s3,v+vr);
						insert(s,del(s2,j+1),s3,v);
					}
					else if(!p1 && p2)
					{
						insert(rem(s,j,p2),chg(s2,j+1,1),s3,v+vr);
						insert(rem(s,j+1,p2),chg(s2,j+1,1),s3,v+vr);
					}
					else if(p1 && !p2)
					{
						insert(rem(s,j,p1),chg(s2,j+1,1),s3,v+vr);
						insert(rem(s,j+1,p1),chg(s2,j+1,1),s3,v+vr);
					}
					else if(p1==1 && p2==1) insert(find_r(s,j,1),chg(s2,j+1,1),s3,v+vr);
					else if(p1==2 && p2==2) insert(find_l(s,j,2),chg(s2,j+1,1),s3,v+vr);
					else if(p1==2 && p2==1) insert(s,chg(s2,j+1,1),s3,v+vr);
					else if(p1==1 && p2==3) insert(find_r(s,j,3),chg(s2,j+1,1),s3,v+vr);
					else if(p1==2 && p2==3) insert(find_l(s,j,3),chg(s2,j+1,1),s3,v+vr);
					else if(p1==3 && p2==1) insert(find_r(s,j,3),chg(s2,j+1,1),s3,v+vr);
					else if(p1==3 && p2==2) insert(find_l(s,j,3),chg(s2,j+1,1),s3,v+vr);
					else if(p1==3 && p2==3) insert(s,chg(s2,j+1,1),s3,v+vr);
				}
				else if(str[i][j]=='S' || str[i][j]=='T')
				{
					if(str[i][j]=='S' && !p1 && !p2)
					{
						insert(rem(s,j,3),chg(s2,j+1,1),s3,v+vr);
						insert(rem(s,j+1,3),chg(s2,j+1,1),s3,v+vr);
					}
					else if(str[i][j]=='T' && !p1 && !p2)
					{
						insert(rem(s,j,3),chg(s2,j+1,1),s3,v+vr);
						insert(rem(s,j+1,3),chg(s2,j+1,1),s3,v+vr);
					}
					else if(!p1 && p2==1) insert(find_r(s,j,3),chg(s2,j+1,1),s3,v+vr);
					else if(!p1 && p2==2) insert(find_l(s,j,3),chg(s2,j+1,1),s3,v+vr);
					else if(p1==1 && !p2) insert(find_r(s,j,3),chg(s2,j+1,1),s3,v+vr);
					else if(p1==2 && !p2) insert(find_l(s,j,3),chg(s2,j+1,1),s3,v+vr);
					else if(p1==3 && !p2) insert(s,chg(s2,j+1,1),s3,v+vr);
					else if(!p1 && p2==3) insert(s,chg(s2,j+1,1),s3,v+vr);
				}
			}
		}
	}
	int ans=0;
	for(int i=1;i<=cnt[u];i++)
	if(!h[u][0][i]) ans=max(ans,f[u][i]);
	printf("%lld",ans);
	return 0;
}
```
