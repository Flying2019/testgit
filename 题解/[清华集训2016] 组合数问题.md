### [链接](https://www.luogu.com.cn/problem/P6669)
一看到 $n,m\leq 10^{18}$，大概率就和各种筛无缘了。

考虑 $k$ 很小，而且还是质数。题目要求 $\binom{i}{j}$ 是 $k$ 的倍数，相当于 $\binom{i}{j}\bmod k=0$。这个可以套用卢卡斯定理。

具体来说，可以发现将 $i,j$ 写成 $k$ 进制 $a_x,b_x$ 后，$\binom{i}{j}=\prod \binom{a_x}{b_x}=0$，也就是说要求至少一位 $a_x<b_x$。

这个直接数位dp处理即可。复杂度 $O(k^2log n)$。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define mod 1000000007
#define N 110
#define ll long long
using namespace std;
int f[N][2][2][2][2],k,len;
int a[N],b[N];
int dfs(int u,bool sm,bool bg,bool g1,bool g2)
{
    if(!u) return sm;
    if(f[u][sm][bg][g1][g2]>=0) return f[u][sm][bg][g1][g2];
    int &r=f[u][sm][bg][g1][g2];
    r=0;
    int m1=g1?k-1:a[u],m2=g2?k-1:b[u];
    for(int i=0;i<=m1;i++)
        for(int j=0;j<=m2 && (bg || j<=i);j++) r=(r+dfs(u-1,sm|| i<j,bg|| i!=j,g1|| i<m1,g2|| j<m2))%mod;
    return r;
}
int main()
{
    int t;
    scanf("%d%d",&t,&k);
    while(t --> 0)
    {
        memset(f,-1,sizeof(f));
        ll n,m;
        len=0;
        scanf("%lld%lld",&n,&m);
        for(ll i=max(n,m);i;i/=k,len++);
        for(int i=1;i<=len;i++,n/=k,m/=k) a[i]=n%k,b[i]=m%k;
        printf("%d\n",dfs(len,0,0,0,0));
    }
    return 0;
}
```
