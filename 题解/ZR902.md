看到多次求LCP，首先先想到SAM。如果要求字典序最小，可以发现SAM中也是可以贪心的。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 2000010
#define C 5
using namespace std;
int lst,ch[N][C],id[N],fa[N],len[N],tot;
void insert(int c,int d)
{
	int p=lst,u=lst=++tot;
	id[u]=d;len[u]=len[p]+1;
	for(;p && !ch[p][c];p=fa[p]) ch[p][c]=u;
	if(!p) fa[u]=1;
	else
	{
		int q=ch[p][c];
		if(len[q]==len[p]+1) fa[u]=q;
		else
		{
			int nq=++tot;
			fa[nq]=fa[q];
			len[nq]=len[p]+1;
			id[nq]=id[q];
			memcpy(ch[nq],ch[q],sizeof(ch[nq]));
			fa[q]=fa[u]=nq;
			for(;p && ch[p][c]==q;p=fa[p]) ch[p][c]=nq;
		}
	}
}
int son[N][C];
int a[N],b[N];
void dfs(int u)
{
	int r1=1e9,r2=1e9;
	if(id[u]) r1=r2=id[u];
	for(int i=3;i>=0;i--)
	if(son[u][i])
	{
		int v=son[u][i];
		dfs(v);
		if(id[v]<r1) r2=r1,r1=id[v];
		else if(id[v]<r2) r2=id[v];
	}
	if(r2<=N) a[len[u]]=r1,b[len[u]]=r2;
	for(int i=3;i>=0;i--)
	if(son[u][i]) id[u]=min(id[u],id[son[u][i]]);
}
char str[N];
void clear(int n)
{
	for(int i=1;i<=n;i++) a[i]=b[i]=n-i+1;
	for(int i=1;i<=n*2+1;i++)
	{
		fa[i]=len[i]=0;
		memset(ch[i],0,sizeof(ch[i]));
		memset(son[i],0,sizeof(son[i]));
	}
	lst=tot=1;
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t --> 0)
	{
		int n;
		scanf("%s",str+1);
		n=strlen(str+1);
		clear(n);
		for(int i=n;i>=1;i--)
		insert(str[i]-'a',i);
		for(int i=2;i<=tot;i++)
		son[fa[i]][str[id[i]+len[fa[i]]]-'a']=i;
		dfs(1);
		for(int i=1;i<=n;i++) printf("%d %d\n",a[i],b[i]);
	}
	return 0;
}
```
