考虑重心的性质：其到所有点的距离和是最短的。由此可以引申出：由一条边连接两棵子树连成的树，其重心一定在两个子树的重心之间。

同时，令一棵树的重心为根，那么一定没有一颗子树的size大于整棵树size的一半。

可以先判断重心在哪个子树上（size超过一半的那颗子树，如果没有的话重心就是根节点），然后暴力将这颗子树的重心向上跳就好了。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 300010
using namespace std;
int nxt[N<<1],to[N<<1],head[N],cnt;
void add(int u,int v)
{
	nxt[++cnt]=head[u];
	to[cnt]=v;
	head[u]=cnt;
}
int rt[N],siz[N],fa[N];
int dfs(int u,int pre)
{
	rt[u]=u;
	siz[u]=1;
	for(int i=head[u];i;i=nxt[i]) siz[u]+=dfs(to[i],u);
	for(int i=head[u];i;i=nxt[i])
	if(siz[to[i]]*2>siz[u]) rt[u]=rt[to[i]];
	while((siz[u]-siz[rt[u]])*2>siz[u]) rt[u]=fa[rt[u]];
	return siz[u];
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=2;i<=n;i++) scanf("%d",&fa[i]),add(fa[i],i);
	dfs(1,0);
	while(m --> 0)
	{
		int u;
		scanf("%d",&u);
		printf("%d\n",rt[u]);
	}
	return 0;
}

```
