### [链接](https://www.luogu.com.cn/problem/P4205)
可以发现题目要求每个点都有珠子+每种珠子只用一次。很显然可以转化成一个精准覆盖的问题，即前55个点用于标记每个点有珠子，后12个点标记每种珠子用一次。

对于8种情况~~分类讨论一下~~直接标记每种珠子的相对位置，对于每种珠子的每种情况计算出此时的位置，判断是否符合即可。

可以发现极限数据也只有 $2\times 10^6$ ，而且行数极少，DLX跑的很快。 
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cstdlib>
#define N 150010
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
using namespace std;
#define AL 12
const int len[AL]={3,4,4,4,5,5,5,5,5,5,5,5};
const int pos[AL][5][2]=
{
    {{0,0},{1,0},{0,1}},
    {{0,0},{0,1},{0,2},{0,3}},
    {{0,0},{1,0},{0,1},{0,2}},
    {{0,0},{1,0},{0,1},{1,1}},
    {{0,0},{1,0},{2,0},{2,1},{2,2}},
    {{0,0},{0,1},{1,1},{0,2},{0,3}},
    {{0,0},{1,0},{0,1},{0,2},{1,2}},
    {{0,0},{1,0},{0,1},{1,1},{0,2}},
    {{0,0},{0,1},{0,2},{1,2},{1,3}},
    {{0,0},{-1,1},{0,1},{1,1},{0,2}},
    {{0,0},{1,0},{1,1},{2,1},{2,2}},
    {{0,0},{1,0},{0,1},{0,2},{0,3}},
};
#define M 15
const int ux[56]={0,1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10};
const int uy[56]={0,1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,10};
char mp[M][M];
bool vis[M];
int num[M][M],cnt,tot;
int tx[2],nx[2],id[N];
namespace DLX{
	int l[N],r[N],u[N],d[N];
	int nx[N],ny[N];
	int h[N],s[N],cnt;
	void init(int m)
	{ 
		for(int i=0;i<=m;i++) r[i]=i+1,l[i]=i-1,u[i]=d[i]=i;
		r[m]=0,l[0]=m;
		memset(h,-1,sizeof(h));
		memset(s,0,sizeof(s));
		cnt=m+1;
	}
	void insert(int x,int y)
	{
		s[y]++;
		nx[cnt]=x,ny[cnt]=y;
		u[cnt]=y;
		d[cnt]=d[y];
		d[y]=u[d[y]]=cnt;
		if(h[x]==-1) h[x]=r[cnt]=l[cnt]=cnt;
		else
		{
			r[cnt]=h[x],l[cnt]=l[h[x]];
			l[h[x]]=r[l[h[x]]]=cnt;
		}
		++cnt;
	}
	void erase(int y)
	{
		r[l[y]]=r[y];
		l[r[y]]=l[y];
		for(register int i=d[y];i!=y;i=d[i])
			for(register int j=r[i];j!=i;j=r[j]) u[d[j]]=u[j],d[u[j]]=d[j],s[ny[j]]--;
	}
	void renew(int y)
	{
		for(register int i=u[y];i!=y;i=u[i])
			for(register int j=l[i];j!=i;j=l[j]) u[d[j]]=j,d[u[j]]=j,s[ny[j]]++;
		r[l[y]]=y;
		l[r[y]]=y;
	}
	bool work(void)
	{
		if(r[0]==0) return true;
		int p=r[0];
		for(register int i=p;i;i=r[i]) if(s[i]<s[p]) p=i;
		erase(p);
		for(register int i=d[p];i!=p;i=d[i])
		{
			if(ny[i]<=55) mp[ux[ny[i]]][uy[ny[i]]]=id[nx[i]]+'A';
			for(register int j=r[i];j!=i;j=r[j])
			{
				erase(ny[j]);
				if(ny[j]<=55) mp[ux[ny[j]]][uy[ny[j]]]=id[nx[j]]+'A';
			}
			if(work()) return true;
			for(int j=l[i];j!=i;j=l[j]) renew(ny[j]);
		}
		renew(p);
		return false;
	}
}
int main()
{
	for(int i=1;i<=10;i++) scanf("%s",mp[i]+1);
	for(int i=1;i<=10;i++)
		for(int j=1;j<=i;j++)
		if(mp[i][j]!='.') vis[mp[i][j]-'A']=true;
	for(int i=1;i<=10;i++)
		for(int j=1;j<=i;j++) num[i][j]=++cnt;
	DLX::init(cnt+12);
	for(register int t=0,u;t<AL;t++)
		for(u=0,++cnt;u<=1;u++)
			for(register int x=-1;x<=1;x+=2)
				for(register int y=-1;y<=1;y+=2)
					for(tx[0]=1;tx[0]<=10;tx[0]++)
						for(tx[1]=1;tx[1]<=tx[0];tx[1]++)
						{
							bool can=1;
							for(register int i=0;i<len[t];i++)
							{
								nx[u]=tx[u]+x*pos[t][i][0];
								nx[u^1]=tx[u^1]+y*pos[t][i][1];
								if(vis[t]){if(mp[nx[0]][nx[1]]!='A'+t){can=false;break;}}
								else if(mp[nx[0]][nx[1]]!='.'){can=false;break;}
							}
							if(!can) continue;
							id[++tot]=t;
							DLX::insert(tot,cnt);
							for(int i=0;i<len[t];i++)
							{
								nx[u]=tx[u]+x*pos[t][i][0];
								nx[u^1]=tx[u^1]+y*pos[t][i][1];
								DLX::insert(tot,num[nx[0]][nx[1]]);
							}
						}
    if(!DLX::work()) puts("No solution");
    else
    {
    	for(register int i=1;i<=10;i++,puts(""))
    		for(register int j=1;j<=i;j++) putchar(mp[i][j]);
	}
	return 0;
}
```
