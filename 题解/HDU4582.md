注意到题目说明了这颗生成树是DFS生成树。所以可以证明所有非树边均为返祖边（就是一端一定是另一端的祖先）。

所以可以发现这些边构成了一些区间，也就是要求所有区间中至少选择一个数。直接贪心即可（能拖就拖，拖不了了再选）。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<bitset>
#define N 200010
#define M 2010
using namespace std;
struct road{
	int nxt[N<<1],to[N<<1],head[N],cnt;
	void add(int u,int v)
	{
		nxt[++cnt]=head[u];
		to[cnt]=v;
		head[u]=cnt;
	}
}r1,r2;
bitset<M>s[M];
int ans=0;
bool vis[N];
void dfs(int u,int pre)
{
	s[u].reset();
	vis[u]=true;
	for(int i=r2.head[u];i;i=r2.nxt[i])
	{
		int v=r2.to[i];
		if(vis[v]) s[u].set(v);
	}
	for(int i=r1.head[u];i;i=r1.nxt[i])
	{
		int v=r1.to[i];
		if(!vis[v]) dfs(v,u);
	}
	if(u==1) return;
	if(s[u].test(pre)) ans++;
	else s[pre]|=s[u];
}
int main()
{
	int n,m;
	while(1)
	{
		scanf("%d%d",&n,&m);
		if(n==0 && m==0) break;
		memset(&r1,0,sizeof(r1));
		memset(&r2,0,sizeof(r2));
		memset(vis,0,sizeof(vis));
		ans=0;
		for(int i=1;i<n;i++)
		{
			int u,v;
			scanf("%d%d",&u,&v);
			r1.add(u,v);
			r1.add(v,u);
		}
		for(int i=n;i<=m;i++)
		{
			int u,v;
			scanf("%d%d",&u,&v);
			r2.add(u,v);
			r2.add(v,u);
		}
		dfs(1,0);
		printf("%d\n",ans);
	}
	return 0;
}
```
