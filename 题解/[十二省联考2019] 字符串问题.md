### [链接](https://loj.ac/problem/3049)
### 题目大意
给一个字符串，有一个二分图 $(A,B)$，每个点代表字符串的一个子串。定义 $B\rightarrow A$ 有边当且仅当 $B$ 是 $A$ 的前缀。

再额外给定一些 $A\rightarrow B$ 的边。定义一条链的价值是经过的 $A$ 点的字符串长度之和，求该有向图的最长链。有环输出 $-1$。
### 题解
显然有一个 $O(n^2)$ 的做法：暴力枚举二分图每个点对 $(a_i,b_j)$ 有无 $b_j\rightarrow a_i$ ，Hash/SA判断是否为前缀，然后跑topo即可。

考虑到这种情况下总边数是 $O(n^2)$ 级别。考虑优化建图。由于这里是前缀，我们不妨把后缀自动机倒过来建，那么这样一个节点代表的就是一段后缀。

我们对于子串 $[l,r]$ 找到 $l$ 对应的SAM上的点，然后倍增找到该子串对应的点的位置，可以发现 $[l,r]$ 的前缀一定在该结点和其祖先上。

那么我们不妨在所有对应在SAM某点上的子串按长度排序，然后我们向前找到第一个 $B$ 类点。显然，由于 $B$ 类点不计点权，所以 $A\rightarrow B'\rightarrow B$ 与 $A\rightarrow B$ 没有本质区别。

然后我们同样把后缀树上的每个点向它父亲表示的最后一个 $B$ 类点连边。可以发现，所有 $A\rightarrow B$ 的边都可以通过走若干点权为0的边得到。

所以再连上额外边，跑一遍topo即可。

复杂度 $O(n\log n)$。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<queue>
#include<algorithm>
#define ll long long
#define N 1000010
#define D 20
using namespace std;
int nxt[N<<4],to[N<<4],deg[N],head[N],rcnt;
void add(int u,int v){nxt[++rcnt]=head[u];to[rcnt]=v;head[u]=rcnt;deg[v]++;}
int las=1,scnt=1,fa[N],f[N][D],ch[N][26],len[N],acnt;
int insert(int c)
{
    int p=las,q=las=++scnt;
    len[q]=len[p]+1;
    for(;p && !ch[p][c];p=fa[p]) ch[p][c]=q;
    if(!p) fa[q]=1;
    else
    {
        int np=ch[p][c];
        if(len[np]==len[p]+1) fa[q]=np;
        else
        {
            int nq=++scnt;
            memcpy(ch[nq],ch[np],sizeof(ch[nq]));
            len[nq]=len[p]+1;
            fa[nq]=fa[np];
            fa[np]=fa[q]=nq;
            for(;p && ch[p][c]==np;p=fa[p]) ch[p][c]=nq;
        }
    }
    return q;
}
int pos[N],cl[N],pa[N],pb[N],lst[N];
vector<int>v[N];
int work(int c)
{
    int l,r;
    scanf("%d%d",&l,&r);
    int u=pos[l];
    ++acnt;
    len[acnt]=r-l+1,cl[acnt]=c;
    for(int i=D-1;i>=0;i--)
        if(f[u][i] && len[f[u][i]]&gt;=len[acnt]) u=f[u][i];
    v[u].push_back(acnt);
    return acnt;
}
bool cmp(int x,int y){return len[x]>len[y] || (len[x]==len[y] && cl[x]>cl[y]);}
char str[N];
queue<int>q;
ll dis[N];
ll topo(int n)
{
    while(!q.empty()) q.pop();
    for(int i=1;i<=n;i++) dis[i]=0;
    for(int i=1;i<=n;i++)
    if(!deg[i]) q.push(i);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=head[u];i;i=nxt[i])
        {
            int v=to[i];
            dis[v]=max(dis[v],dis[u]+len[u]);
            --deg[v];
            if(!deg[v]) q.push(v);
        }
    }
    ll ans=0;
    for(int i=1;i<=n;i++)
    if(deg[i]) return -1;
    else ans=max(ans,dis[i]+len[i]);
    return ans;
}
void work()
{
    scanf("%s",str+1);
    int n=strlen(str+1),m;
    ll ans=0;
    for(int i=n;i>=1;i--) pos[i]=insert(str[i]-'a');
    for(int i=1;i<=scnt;i++) f[i][0]=fa[i];
    for(int j=1;j<D;j++)
        for(int i=1;i<=scnt;i++) f[i][j]=f[f[i][j-1]][j-1];
    acnt=scnt;
    scanf("%d",&m);
    for(int i=1;i<=m;i++) pa[i]=work(1);
    scanf("%d",&m);
    for(int i=1;i<=m;i++) pb[i]=work(0);
    for(int i=1;i<=scnt;i++) sort(v[i].begin(),v[i].end(),cmp),reverse(v[i].begin(),v[i].end());
    for(int i=1;i<=scnt;i++)
    {
        int u=i;
        for(int t:v[i]) add(u,t),u=cl[t]?u:t;
        lst[i]=u;
    }
    for(int i=2;i<=scnt;i++) add(lst[fa[i]],i);
    for(int i=1;i<=acnt;i++) if(!cl[i]) len[i]=0;
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        add(pa[u],pb[v]);
    }
    printf("%lld\n",topo(acnt));
    for(int i=1;i<=acnt;i++) memset(ch[i],0,sizeof(ch[i])),memset(f[i],0,sizeof(f[i]));
    for(int i=1;i<=acnt;i++) fa[i]=len[i]=0,head[i]=deg[i]=cl[i]=0,v[i].clear();
    acnt=scnt=las=1;
    rcnt=0;
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t --> 0) work();
    return 0;
}
```
