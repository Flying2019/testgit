### [链接](https://www.luogu.com.cn/problem/P4565)[_](https://loj.ac/problem/2553)
~~一个 long long 调一天~~

首先先把式子变形，可以发现：$\frac 1 2\left(\operatorname{dis}(x,y)+\operatorname{dep}_x+\operatorname{dep}_y-2\operatorname{dep'}_{\operatorname{lca'}(x,y)}\right)$。

这很明显是一个关于第一颗树的 $\operatorname{dis}$ 和第二棵树的 $\operatorname{dep}$ 的问题。

我们假如钦定了第一颗树的某条边是必经边，那么我们可以将整棵树分成两半，一半黑点一半白点。这样就可以给每一个点附一个权值，然后dp即可。

这个步骤就很像点分治了，那么我们不妨按照点分治来做，这样就是 $O(\log n)$ 的。

但是这里dp有点问题，因为我们需要建一个虚树。而且这里毒瘤卡常，$O(n\log n)$ 不是很好写。

我们考虑换一种方法：倒过来，我们枚举 $\operatorname{lca'}(x,y)$，然后考虑其可行贡献的最大值。

这样的话，我们把每个点的祖先边分治中心全部统计进去（类似于点分树？），然后我们黑点放左边，白点放右边，根据每个点关于祖先边分治中心的染色情况，建出一个类似于trie的东西（可以发现每个点有一个唯一的编号），处理的时候合并上去，顺便处理答案即可。

但是直接这样做，一个菊花图就卡爆了，trie的深度会达到 $O(n)$ 级别，显然不能接受。

考虑转换。我们在每个点上建立一个虚点，虚点的左儿子为其对应点，右儿子是对应点下一个兄弟的虚点，兄弟中第一个虚点向其父亲连一条边。虚点向对应点的边权为对应点到其父亲的边权，其余边权均为0。可以发现，这样两点之间的距离没有改变，但是树变成二叉树了。

然后套用上述方式进行处理即可。复杂度 $O(n\log n)$。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#define N 1600010
#define ll long long
using namespace std;
int nxt[N<<1],to[N<<1],head[N],cnt=1,ext,n;
ll wv[N<<1],dep[N];;
void add(int u,int v,ll w)
{
	nxt[++cnt]=head[u];to[cnt]=v,wv[cnt]=w,head[u]=cnt;
	nxt[++cnt]=head[v];to[cnt]=u,wv[cnt]=w,head[v]=cnt;
}
struct road{int v,w;road(int V=0,int W=0):v(V),w(W){}};
vector<road>g[N];
void preb(int u,int p)
{
	int q=u;
	for(road o:g[u])
	if(o.v!=p)
	{
		add(++ext,q,0),add(ext,o.v,o.w);
		dep[o.v]=dep[u]+o.w,q=ext;
		preb(o.v,u);
	}
}
int siz[N],cut[N<<1];
int all,id,mrt;
void dfs(int u,int p)
{
	siz[u]=1;
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==p || cut[i]) continue;
		dfs(v,u);
		siz[u]+=siz[v];
		int mn=max(siz[u],all-siz[u]);
		if(mn<mrt) mrt=mn,id=i;
	}
}
struct node{ll dis;int w;node(ll D=0,int W=0):dis(D),w(W){}};
vector<node>pos[N];
int ch[N*20][2],root[N],tot;
ll sv[N*20][2];
void work(int u,int p,ll d,int o)
{
	siz[u]=1;
	if(u<=n) pos[u].push_back(node(d+dep[u],o));
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==p || cut[i]) continue;
		work(v,u,d+wv[i],o);
		siz[u]+=siz[v];
	}
}
void solve(int u)
{
	if(siz[u]==1) return;
	all=siz[u],mrt=1e8;dfs(u,0);
	int v=to[id];u=to[id^1];
	cut[id]=cut[id^1]=true;
	work(v,0,0,0),work(u,0,wv[id],1);
	solve(v),solve(u);
}
#define inf 1e17
void build(int &u,vector<node> &v,int pv)
{
	if(pv>=(int)v.size()) return;u=++tot;
	sv[u][v[pv].w]=v[pv].dis;sv[u][!v[pv].w]=-inf;
	build(ch[u][v[pv].w],v,pv+1);
}
ll ans=-inf,rdis;
int merge(int x,int y)
{
	if(!x || !y) return x+y;
	ans=max(ans,max(sv[x][0]+sv[y][1],sv[y][0]+sv[x][1])-2*rdis);
	for(int _=0;_<=1;_++) sv[x][_]=max(sv[x][_],sv[y][_]),ch[x][_]=merge(ch[x][_],ch[y][_]);
	return x;
}
void answer(int u,int p,ll d)
{
	ans=max(ans,2*(dep[u]-d));
	for(road o:g[u])
	if(o.v!=p)
	{
		answer(o.v,u,d+o.w);rdis=d;
		root[u]=merge(root[u],root[o.v]);
	}
}
int main()
{
	scanf("%d",&n);ext=n;
	for(int i=1;i<n;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		g[u].push_back(road(v,w)),g[v].push_back(road(u,w));
	}
	preb(1,0);siz[1]=ext;
	solve(1);
	for(int i=1;i<=n;i++) build(root[i],pos[i],0);
	for(int i=1;i<=n;i++) g[i].clear();
	for(int i=1;i<n;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		g[u].push_back(road(v,w)),g[v].push_back(road(u,w));
	}
	answer(1,0,0);
	printf("%lld\n",ans>>1);
	return 0;
}
```
