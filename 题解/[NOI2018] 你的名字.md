### [链接](https://www.luogu.com.cn/problem/P4770)
### 题目大意
给定一个串 $S$，多次询问一个串 $t_i$ 没有在 $S$ 的 $[l,r]$ 子串中出现过的本质不同子串个数。
### 题解
我们知道 SAM 是一种自动机，每条路径都代表着一个子串，可以用跑AC自动机的方法去跑 SAM 的匹配。

按照套路，我们先考虑 $l=1,r=|S|$ 的情况。按照套路，我们先建出 $S$ 和 $s_i$ 的后缀自动机。

考虑一个很显然的结论：如果 $s_i$ 的某个子串 $t$ 在 $S$ 中出现过，那么 $t$ 的后缀也一定在 $S$ 中出现过。

所以我们只需要对 $s_i$ 的每一个前缀，找到最短的后缀使其没有在 $S$ 中出现过。但是这样没办法处理“本质不同”这个条件。

我们知道后缀自动机上一个点 $u$ 代表的状态其实是某个前缀的长度大于 $len_{fa}$ 的后缀。也就是说，对于 $s_i$ 后缀自动机的一个节点 $u$，我们找到最短的长度 $Len_u$ 使该长度的后缀没有在 $S$ 中出现过，那么答案就是 $\sum_{u}\left(len_u-\max{(len_{fa},Len_u)}\right)$。

考虑如何得到 $Len_u$。我们知道一个后缀自动机上的节点对应的是一个后缀（包括分裂出来的节点）。显然我们对每一个后缀，类似于AC自动机一样，如果当前字符在 $S$ 的后缀自动机的当前节点上有转移，我们就转移并让匹配长度+1，否则一直让匹配长度-1并一直跳parent树直到存在转移。

至此为之你已经可以在这道题上拿到**68**分的好成绩，~~见好就收~~。

接下来考虑一般情况。可以发现，对于 $[l,r]$ 子串，唯一的区别就是原SAM的某些转移边不一定可行。

具体来说，对于某个点 $u$，如果其endpos集合中存在一个点使其完全在 $[l,r]$ 中出现，那么转移到该点的转移边一定合法。

所以我们只需要对 $S$ 的SAM的endpos集合进行线段树合并，然后对于 $u$ 查询 $[l+len,r]$ 区间是否存在endpos。其他同 $l=1,r=|S|$。

复杂度 $O(n\log n)$。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 1000010
#define C 26
#define ll long long
using namespace std;
int rt[N],num[N],tcnt;
struct node{
    int l,r,v;
}t[N*60];
ll ans;
int build(int l,int r,int p)
{
    int u=++tcnt;
    t[u].v++;
    if(l==r) return u;
    int mid=(l+r)>>1;
    if(p<=mid) t[u].l=build(l,mid,p);
    else t[u].r=build(mid+1,r,p);
    return u;
}
int answer(int u,int l,int r,int L,int R)
{
    if(!u || L>R) return 0;
    if(L<=l && r<=R) return t[u].v;
    int mid=(l+r)>>1;
    if(L>mid) return answer(t[u].r,mid+1,r,L,R);
    if(R<=mid) return answer(t[u].l,l,mid,L,R);
    return answer(t[u].l,l,mid,L,R)+answer(t[u].r,mid+1,r,L,R);
}
int merge(int x,int y)
{
    if(!x || !y) return x+y;
    int u=++tcnt;
    t[u].v=t[x].v+t[y].v;
    t[u].l=merge(t[x].l,t[y].l);
    t[u].r=merge(t[x].r,t[y].r);
    return u;
}
int n,m;
struct SAM{
    int ch[N][C+1],cnt,las;
    int len[N],fa[N],f[N];
    SAM(){cnt=las=1;}
    void reset(){memset(ch[1],0,sizeof(ch[1]));cnt=las=1;}
    void insert(int c,int pos=0)
    {
        int p=las,u=las=++cnt;
        memset(ch[u],0,sizeof(ch[u]));
        f[u]=len[u]=len[p]+1;
        for(;p && !ch[p][c];p=fa[p]) ch[p][c]=u;
        if(!p) fa[u]=1;
        else
        {
            int q=ch[p][c];
            if(len[q]==len[p]+1) fa[u]=q;
            else
            {
                int nq=++cnt;
                f[nq]=f[q];
                len[nq]=len[p]+1;
                memcpy(ch[nq],ch[q],sizeof(ch[q]));
                fa[nq]=fa[q];
                fa[u]=fa[q]=nq;
                for(;p && ch[p][c]==q;p=fa[p]) ch[p][c]=nq;
            }
        }
        if(pos) rt[u]=::build(1,n,pos);
    }
    int res[N],sa[N];
    void build()
    {
        for(int i=1;i<=cnt;i++) res[len[i]]++;
        for(int i=1;i<=n;i++) res[i]+=res[i-1];
        for(int i=1;i<=cnt;i++) sa[res[len[i]]--]=i;
        for(int i=cnt;i;i--)
        {
            int u=sa[i];
            rt[fa[u]]=merge(rt[u],rt[fa[u]]);
        }
    }
    void find(int &u,int &len,int l,int r,int c)
    {
        while(1)
        {
            if(ch[u][c] && answer(rt[ch[u][c]],1,n,l+len,r))
            {
                ++len;
                u=ch[u][c];
                return;
            }
            if(!len) return;
            if(--len==SAM::len[fa[u]]) u=fa[u];
        }
    }
    ll work(int a[])
    {
        ll res=0;
        for(int i=2;i<=cnt;i++)
            res+=max(0,len[i]-max(len[fa[i]],a[f[i]]));
        return res;
    }
}s1,s2;
char str[N],s[N];
int a[N];
int main()
{
    scanf("%s",str+1);
    n=strlen(str+1);
    for(int i=1;i<=n;i++) s1.insert(str[i]-'a',i);
    s1.build();
    scanf("%d",&m);
    while(m --> 0)
    {
        int l,r;
        scanf("%s%d%d",s+1,&l,&r);
        int n1=strlen(s+1);
        s2.reset();
        int u=1;
        for(int i=1;i<=n1;i++)
        {
            a[i]=a[i-1];
            s1.find(u,a[i],l,r,s[i]-'a');
            s2.insert(s[i]-'a');
        }
        printf("%lld\n",s2.work(a));
    }
    return 0;
}
```
