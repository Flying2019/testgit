博弈论贪心，考虑用平衡树（类似于ODT）的想法进行优化。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<set>
#include<queue>
#define N 1000010
#define P pair<int,int>
#define SP set<P >
#define MP make_pair
#define be begin
#define ed end
#define L first
#define R second
#define si SP::iterator
using namespace std;
SP s[2];
char str[N];
priority_queue<P,vector<P >,greater<P > >q[2];
int num[N],cnt[2],ans[N];
int main()
{
	int n,m,tot=0,k=0;
	scanf("%d%d%s",&n,&m,str+1);
	for(int i=1;i<=n;i++)
	if(str[i]=='1')
	{
		num[++tot]=k;
		k=0;
	}
	else ++k;
	s[tot&1].insert(MP(n*2+1,tot+1));
	for(int i=tot;i;i--)
	{
		int u=i&1,p=!u;
		s[p].insert(MP(i*2,1-cnt[p]));
		q[p].push(MP(1-cnt[p],i*2));
		while(num[i]--)
		{
			cnt[p]++;
			cnt[u]--;
			for (;!q[u].empty();q[u].pop())
			{
				P v=q[u].top();
				si swp=s[u].find(MP(v.R,v.L)),pl,pr;
				if(swp==s[u].end()) continue;
				if(v.L+cnt[u]!=0) break;
				s[u].erase(swp);
				pl=pr=s[p].lower_bound(MP(v.R,0));
				--pr;
				int l=pr->L,r=pl->R+pr->R+cnt[p];
				s[p].erase(pr);
				s[p].erase(s[p].lower_bound(MP(v.R,0)));
				s[p].insert(MP(l,r));
				q[p].push(MP(r,l));
			}
		}
	}
	tot=0;
	while(!s[0].empty() || !s[1].empty())
	{
		if(s[0].empty() || (!s[1].empty() && s[1].begin()->L<s[0].begin()->L))
		{
			int r=(s[1].begin()->R)+cnt[1];
//			if(r<0) continue;
			while(r--) ans[tot++]=1;
			s[1].erase(s[1].begin());
		}
		else
		{
			int r=(s[0].begin()->R)+cnt[0];
//			if(r<0) continue;
			while(r--) ans[tot++]=0;
			s[0].erase(s[0].begin());
		}
	}
	for(int i=1;i<=m;i++)
	{
		int x;
		scanf("%d",&x);
		printf("%d\n",ans[x]);
	}
	return 0;
}
```
反思：内部变量一定要赋初值，而且本地好像会帮你赋值好初值导致发现不了。
