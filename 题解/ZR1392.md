分析样例后可以猜测：最多两个分成一组。可以发现这满足二分图的性质。

利用Hall定理贪心做一下就行了
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<set>
#define vt vector
#define N 18
#define M 1<<N
using namespace std;
int n,k;
vt<vt<int> >ans;
vt<int>r[N],swp;
int popcnt[M],link[M];
set<int>s;
int main()
{
	scanf("%d%d",&n,&k);
	int m=1<<n;
	for(int i=1;i<m;i++)
	{
		popcnt[i]=popcnt[i>>1]+(i&1);
		r[popcnt[i]].push_back(i);
	}
	for(int i=0;2*i<=k;i++)
	{
		s.clear();
		for(int j=0;j<r[i].size();j++)
			s.insert(r[i][j]);
		int j=0,u=0;
		while(!s.empty() && (i*2!=k || s.size()>1))
		{
			u=*s.begin();
			for(;;j++)
			{
				if(j==r[k-i].size()) j=0;
				if((r[k-i][j]&u)==0)
				{
					int v=r[k-i][j];
					if(link[v]) link[link[v]]=0,s.insert(link[v]);
					else s.erase(v);
					link[u]=v,link[v]=u;
					s.erase(u);
					j++;
					break;
				}
			}
		}
	}
	for(int i=1;i<m;i++)
	if(popcnt[i]<=k)
	{
		if(link[i])
		{
			if(link[i]>i)
			{
				swp.clear();
				swp.push_back(i);
				swp.push_back(link[i]);
				ans.push_back(swp);
			}
		}
		else
		{
			swp.clear();
			swp.push_back(i);
			ans.push_back(swp);
		}
	}
	printf("%d\n",ans.size());
	for(int i=0;i<ans.size();i++)
	{
		printf("%d",ans[i].size());
		for(int j=0;j<ans[i].size();j++)
		{
			putchar(' ');
			for(int p=0;p<n;p++)
				if(ans[i][j]&(1<<p)) putchar('a'+p);
		}
		puts("");
	}
	return 0;
}
```
