### [链接](https://www.luogu.com.cn/problem/P1971)
考虑空白格的移动路径，首先可以发现：由于平面图上一条路径组成的环一定是偶数环，所以这个空白格的路径不可能组成一个环。

仔细分析可以发现：这些路径依次通过的是黑白交替的格子且一个格子最多经过一次。考虑将黑点和空白格放在左边，白点放在右边，那么操作等同于将空白格先往左移再往右移，且一个点最多被经过一次。

胜负就取决于这段路径的奇偶性。~~显然~~可以发现，假如一方有必胜策略，当且仅当当前的点是“完美匹配点”（即去掉这个点后完美匹配数量减少）。

那么对于每次操作，判断当前点是否为“完美匹配点”。由于数据规模极小，直接暴力重新匈牙利一遍都可以过。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 60
#define D N*N*2
#define M N*N*8
using namespace std;
int nxt[M],to[M],head[D],cnt;
int u[4]={0,1,0,-1},
	v[4]={1,0,-1,0};
void add(int u,int v)
{
	nxt[++cnt]=head[u];
	to[cnt]=v;
	head[u]=cnt;
}
int link[D];
bool vis[D],cut[D];
bool check(int u)
{
	if(cut[u]) return false;
	vis[u]=true;
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(cut[v]) continue;
		if(!link[v] || (!vis[link[v]] && check(link[v])))
		{
			link[v]=u,link[u]=v;
			return true;
		}
	}
	return false;
}
int n,m,k;
int id(int x,int y){return (x-1)*m+y;}
bool c[N][N];
char str[N];
int res[D],ans[D],acnt;
int main()
{
	int nx=0,ny=0;
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",str+1);
		for(int j=1;j<=m;j++)
		{
			c[i][j]=str[j]!='O';
			if(str[j]=='.') nx=i,ny=j;
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		if(c[i][j])
			for(int k=0;k<4;k++)
			if(i+u[k]<=n && i+u[k]>=1 && j+v[k]<=m && j+v[k]>=1 && !c[i+u[k]][j+v[k]]) add(id(i,j),id(i+u[k],j+v[k])),add(id(i+u[k],j+v[k]),id(i,j));
	int tot=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		if(c[i][j])
		{
			memset(vis,0,sizeof(vis));
			check(id(i,j));
		}
	int m;
	scanf("%d",&m);
	m<<=1;
	for(int i=1;i<=m;i++)
	{
		int u=id(nx,ny);
		cut[u]=true;
		if(link[u])
		{
			memset(vis,0,sizeof(vis));
			int v=link[u];
			link[u]=link[v]=0;
			res[i]=!check(v);
		}
		scanf("%d%d",&nx,&ny);
	}
	for(int i=1;i<=m;i+=2)
	if(res[i] && res[i+1]) ans[++acnt]=(i+1)/2;
	printf("%d\n",acnt);
	for(int i=1;i<=acnt;i++) printf("%d\n",ans[i]);
	return 0;
}
```
