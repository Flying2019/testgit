点分治，暴力处理到点分治中心的距离最小值。
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#define N 200010
#define D 50
using namespace std;
int nxt[N<<1],to[N<<1],head[N],cnt;
int siz[N],dep[N],maxn[N];
int ti[N],t;
void add(int u,int v)
{
	nxt[++cnt]=head[u];
	to[cnt]=v;
	head[u]=cnt;
}
bool vis[N];
int rt,sum;
void get_siz(int u)
{
	ti[u]=t;
	siz[u]=1;
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(vis[v] || ti[v]==t)continue;
		get_siz(v);
		siz[u]+=siz[v];
	}
}
void get_rt(int u)
{
	ti[u]=t;
	maxn[u]=sum-siz[u];
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(vis[v] || ti[v]==t) continue;
		get_rt(v);
		maxn[u]=max(maxn[u],siz[v]);
	}
	if(maxn[u]<maxn[rt]) rt=u;
}
queue<int>q;
int dis[D][N];
void bfs(int k,int s)
{
	q.push(s);
	dis[k][s]=0;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=nxt[i])
		{
			int v=to[i];
			if(!vis[v] && !dis[k][v]) dis[k][v]=dis[k][u]+1,q.push(v);
		}
	}
}
int fa[N];
void solve(int x);
void dfs(int u,int pre)
{
	++t;
	get_siz(u);
	sum=siz[u];
	++t;
	rt=0;
	get_rt(u);
	fa[rt]=pre;
	solve(rt);
}
void solve(int u)
{
	vis[u]=1;
	dep[u]=dep[fa[u]]+1;
	bfs(dep[u],u);
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(vis[v]) continue;
		dfs(v,u);
	}
}
int f[N],n;
void change(int u){for(int i=u;i;i=fa[i]) f[i]=min(f[i],dis[dep[i]][u]);}
int answer(int u)
{
	int res=n+1;
	for(int i=u;i;i=fa[i]) res=min(res,dis[dep[i]][u]+f[i]);
	return res;
}

int main()
{
	int m,t,q;
	scanf("%d%d%d",&n,&m,&t);
	for(int i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);add(v,u);
	}
	maxn[0]=n+1;
	dfs(1,0);
	scanf("%d",&q);
	for(int i=1;i<=n;++i) f[i]=n+1;
	while(q --> 0)
	{
		int opt,x;
		scanf("%d%d",&opt,&x);
		if(opt==1) change(x);
		else printf("%d\n",answer(x));
	}
	return 0;
}
```
反思：每次点分治前要记得清0.
