### [链接](https://darkbzoj.tk/problem/3786)
### 题目大意
给定一颗有根树，支持子树加，修改父亲，询问某个点到父亲的点权和。
### 题解
因为有子树加，LCT有点麻烦，考虑使用ETT。

可以发现，假如我们把这棵树dfs遍历一遍，然后对每个节点进入和退出时分别记录一次。

然后在另一个数组里进入时 $+v$，退出时 $-v$，可以发现，每个结点的第一次出现位置的前缀和就是它到根的路径上的点权和。

要维护这个东西，显然可以直接用各种支持区间插入、删除的数据结构。显然只要是平衡树都可以维护。直接套即可。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<cstdlib>
#define N 200010
#define ll long long
using namespace std;
int cnt,id[N],siz[N],ch[N][2],fa[N],typ[N],rnd[N];
ll val[N],sum[N],tag[N];
int newnode(int v,int type)
{
    siz[++cnt]=1;sum[cnt]=val[cnt]=v*type;
    typ[cnt]=id[cnt]=type;
    rnd[cnt]=rand();
    return cnt;
}
void update(int x)
{
    siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+1;
    id[x]=id[ch[x][0]]+id[ch[x][1]]+typ[x];
    sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+val[x];
}
void set_tag(int u,ll v){val[u]+=typ[u]*v; sum[u]+=id[u]*v; tag[u]+=v;}
void push_down(int u)
{
    if(!tag[u]) return;
    if(ch[u][0]) set_tag(ch[u][0],tag[u]);
    if(ch[u][1]) set_tag(ch[u][1],tag[u]);
    tag[u]=0;
}
inline void chgf(int u,int f){if(u) fa[u]=f;}
int merge(int x,int y)
{
    if(!x || !y) return x+y;
    push_down(x);push_down(y);
    if(rnd[x]<rnd[y]){ch[x][1]=merge(ch[x][1],y);chgf(ch[x][1],x);update(x);return x;}
    else {ch[y][0]=merge(x,ch[y][0]);chgf(ch[y][0],y);update(y);return y;}
}
void split(int x,int k,int &l,int &r)
{
    if(!x){l=r=0;return;}
    push_down(x);
    if(k<=siz[ch[x][0]]){r=x;fa[ch[x][0]]=0;split(ch[x][0],k,l,ch[x][0]);chgf(ch[x][0],x);update(x);return;}
    else{l=x;fa[ch[x][1]]=0;split(ch[x][1],k-siz[ch[x][0]]-1,ch[x][1],r);chgf(ch[x][1],x);update(x);return;}
}
int root,lt,mt,rt,st;
void add(int l,int r,ll v)
{
    split(root,l-1,lt,mt);
    split(mt,r-l+1,mt,rt);
    set_tag(mt,v);
    root=merge(merge(lt,mt),rt);    
}
int ptot=0;
int kth(int x)
{
    int son=1,ans=0;
    while(x)
    {
        if(son) ans+=siz[ch[x][0]]+1;
        son=ch[fa[x]][1]==x;
        x=fa[x];
        // printf("%d ",x);
        // ++ptot;
        // if(ptot>1000) throw;
    }
    return ans;
}
int w[N];
vector<int>rd[N];
int l[N],r[N];
void dfs(int u)
{
    l[u]=newnode(w[u],1);
    root=merge(root,l[u]);
    for(int v:rd[u]) dfs(v);
    r[u]=newnode(w[u],-1);
    root=merge(root,r[u]);
}
char opt[4];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=2;i<=n;i++)
    {
        int fa;
        scanf("%d",&fa);
        rd[fa].push_back(i);
    }
    for(int i=1;i<=n;i++) scanf("%d",&w[i]);
    dfs(1);
    int t;
    scanf("%d",&t);
    while(t --> 0)
    {
        int x,y;
        scanf("%s%d",opt,&x);
        if(opt[0]=='Q')
        {
            split(root,kth(l[x]),lt,rt);
            printf("%lld\n",sum[lt]);
            root=merge(lt,rt);
        }
        else if(opt[0]=='C')
        {
            scanf("%d",&y);
            split(root,kth(l[x])-1,lt,mt);
            split(mt,kth(r[x]),mt,rt);
            st=merge(lt,rt);
            split(st,kth(l[y]),lt,rt);
            rt=merge(merge(lt,mt),rt);
        }
        else if(opt[0]=='F')
        {
            scanf("%d",&y);
            add(kth(l[x]),kth(r[x]),y);
        }
    }
    return 0;
}
```

