### [链接](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2989)
题面有点奇葩，尤其还是英文题面。。。考虑因为所有的 $a_i$ 都是非负数，所以所有的负数都会被统一操作，所以相对顺序一定保持不变（最多由小于变成等于）。

再考虑所有正数。可以发现经过这次操作一定会变大，而且大的数字变大的量更大。所以所有数字的相对位置都保持不变。

那么很显然排个序，最后满足条件的序列一定是其中的一个区间。

考虑二分这个区间的右端点和左端点即可。复杂度 $O(n\log n)$。
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#define N 200010
#define ll long long
using namespace std;
ll num[N],n,q,l,r;
struct node{
	ll opt,x,s,t;
}p[N];
short int check(ll x)
{
	for(int i=1;i<=q;i++)
	{
		if(p[i].opt==1 && x>=p[i].x) x=(x+p[i].s)*p[i].t;
		else if(p[i].opt==2 && x<=p[i].x) x=(x-p[i].s)/p[i].t;
	}
	if(x<l) return -1;
	if(x>r) return 1;
	return 0;
}
int main()
{
	scanf("%lld%lld%lld%lld",&n,&q,&l,&r);
	for(int i=1;i<=n;i++) scanf("%lld",&num[i]);
	sort(num+1,num+n+1);
	for(int i=1;i<=q;i++)
	scanf("%lld%lld%lld%lld",&p[i].opt,&p[i].x,&p[i].s,&p[i].t);
	int l=1,r=n,p=0;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		int t=check(num[mid]);
		if(t==1) r=mid-1;
		else if(t==-1) l=mid+1;
		else{p=mid;break;}
	}
	if(!p){puts("0");return 0;}
	l=p+1,r=n;
	int rf=p;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check(num[mid])==0) l=mid+1,rf=mid;
		else r=mid-1;
	}
	l=1,r=p-1;
	int lf=p;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check(num[mid])==0) r=mid-1,lf=mid;
		else l=mid+1;
	}
	printf("%d\n",rf-lf+1);
	return 0;
}
```
