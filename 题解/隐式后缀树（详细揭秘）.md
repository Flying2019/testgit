[更好地理解隐式后缀树](http://brenden.github.io/ukkonen-animation/)

如果上不去这里有个[离线版本](https://pan.baidu.com/s/1HuNT4zb6eEZhArbRLyyQYQ)，提取码：9cxa。

后缀树想必大家都很熟悉。但是隐式后缀树是怎么回事呢？大家可能会感到很惊讶，怎么会有隐式后缀树写法呢？但事实就是这样，小编也感到非常惊讶。下面就让小编带大家一起了解吧。

以下内容部分参考 https://www.jianshu.com/p/d35acf651d98 和 https://zhuanlan.zhihu.com/p/51880239 。

有兴趣的可以参考[原论文](https://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf)

隐式后缀树采用的建树方法是 Ukkonen's Algorithm。
#### 隐式后缀树的一些性质
1. 隐式后缀树的叶节点**永远是叶节点**。
2. 链接非叶子节点的边表示一段字符串，而连接叶子节点的边则是从某个点开始的后缀。所以连接叶子节点的边代表的字符串不是固定的。
3. 隐式后缀树最后需要添加一个特殊字符，以此把所有字符串都表示出来。这个后面会提到。
4. 隐式后缀树每插入一个节点会恰好多出一个叶子。每个叶子也恰好对应一个后缀。
#### 几个定义
节点 $u$ 所表示的字符串：指后缀树上根到 $u$ 路径首尾相连组成的字符串。

隐式包含：若一个字符串 $s$ 是后缀树上某一点 $u$ 所表示字符串的一个前缀，就称 $s$ 被隐式包含。

Suffix Link：节点 $u$ 所表示字符串的最长**后缀**所在位置。

待插入队列：把待插入的字符看做一个队列。每次插入的是**队列中所有元素组成的字符串**。
### 建树流程
图片均由 [Visualization of Ukkonen's Algorithm](http://brenden.github.io/ukkonen-animation/) 构造。

比如我们要插入 $\texttt{aabababba}$

![](https://images.cnblogs.com/cnblogs_com/Flying2018/1858534/o_201005094748Screenshot%202020-10-05%20174342.png)

首先加入一个字符 $\texttt{a}$，由于这是第一个字符，我们直接插入即可。

![](https://images.cnblogs.com/cnblogs_com/Flying2018/1858534/o_201005094906111.png)

再加入一个字符 $\texttt{a}$。我们发现它被隐式包含了。所以我们将其压入队列，暂时不做处理。而现在活动节点移到了边上，不妨称作活动边。

![](https://images.cnblogs.com/cnblogs_com/Flying2018/1858534/o_201005100011111.png)

由于前面的 $\texttt{a}$ 还没有插入，所以这次将要插入的是 $\texttt{ab}$ ，而 $\texttt{ab}$ 并没有被隐式包含。

我们现在的位置是 $\texttt{a|a}$ ，在一条边的中间。所以我们需要插入一个节点。

**注意这里的标号**，1节点仍然是叶子节点，在他们中间设置了一个分隔点2。

但是这样是不是需要改变1的边的长度呢？这就涉及之前所说的一个性质：一个叶子节点**所表示的字符串**是一段后缀。我们记录的仅仅是这个后缀开始的位置。

由于我们是向后加字符，所以这里后缀的位置是不会发生变化的，而插入一个节点也不会改变叶子节点所表示的字符串。我们并不必在意这条边代表的**实际的字符串**是什么。

插入之后，我们就可以再挂一个叶子节点，以此插入 $\texttt{ab}$ 这个串。然后 $\texttt{a}$ 就可以弹出队列。

![](https://images.cnblogs.com/cnblogs_com/Flying2018/1858534/o_201005101014111.png)

接下来我们发现要插入的 $b$ 没有被隐式包含，而当前活动节点也在完整的节点上，所以直接插入一个叶子即可。

![](https://images.cnblogs.com/cnblogs_com/Flying2018/1858534/o_201005101913111.png)

再次加入 $\texttt{a}$，将其压入队列，同时转移活动节点。发现转移后是一个完整节点，直接转移即可。

![](https://images.cnblogs.com/cnblogs_com/Flying2018/1858534/o_201005105213111.png)

加入 $\texttt{b,a,b}$，所有子串均被隐式包含，所以都压入队列。转移后不是一个完整节点，设置转移边。

由此也可以发现：活动节点永远都不会转移到一个叶子上。

![](https://images.cnblogs.com/cnblogs_com/Flying2018/1858534/o_201005105332111.png)

加入 $\texttt{b}$，$\texttt{ababb}$ 没有被隐式包含，所以插入一个节点。需要注意的是尽管这张图片里没有Suffix Link，但实际上所有点默认的Suffix Link都是根节点。

而每次插入一个节点后我们是需要跳Suffix Link直到活动节点表示的字符串长度小于插入字符串。因为只有这样才能插入该字符串。

所以插入结束后活动节点在根的位置。但是此时活动边还是存在的，因为还有 $\texttt{babb}$ 没有被隐式包含。

然后重复上述步骤直到要插入字符串被隐式包含。

![](https://images.cnblogs.com/cnblogs_com/Flying2018/1858534/o_201005110205111.png)

我们发现图中多出了很多条Suffix Link。特别的我们并不处理叶子节点的Suffix Link，因为这没有任何意义。

![](https://images.cnblogs.com/cnblogs_com/Flying2018/1858534/o_201005110737111.png)

加入 $\texttt{ba}$，可以发现均被隐式包含，直接处理。

然后呢？好像所有字符都处理完了？可是这不是还有两个字母在队列里吗？

所以接下来就需要插入一个终止符号 $\$$，这样所有字母就出队列了。

![](https://images.cnblogs.com/cnblogs_com/Flying2018/1858534/o_201005111137111.png)

有兴趣的可以打一个普通的后缀树看看，应该是本质相同的（当然要算上终止符号才行）。
### 代码
别看说得很复杂，其实代码还是很小清新的。
#### 几个重要的变量
```cpp
int ch[N][27],nxt[N]={0,1},fa[N],len[N];
const int *pos[N];
int tot=1,rm,ac=1,acs=1;
```
这里的 `ch` 指**后缀树**上的边的关系。`nxt` 就是Suffix Link。

`pos` 为了方便书写这里使用指针，表示的是 `u` 到其父亲的边表示的字符串是从原字符串的 `pos[u]` 开始的。

`ac` 表示的是当前活动节点，`acs` 表示活动节点对应活动边的子节点，`rm` 表示待插入队列长度。

首先我们插入一个字符，先将其加入待插入队列。特别的，由于队列一定由后 $rm$ 个字符构成，所以只需记录 $rm$ 即可。

由于我们需要知道当前插入的 $c$ 的地址，为了方便，我们直接传入一个地址即可。

这样，队首的指针就是 `&c-rm`，可以直接得到。

还是以一道例题来解释：[不同子串个数](https://www.luogu.com.cn/problem/P2408)。

由于最后建出的树本质上就是一棵后缀树，所以可以记录每个节点的len，离线处理结果。

为了计算方便，这里直接计算出每个叶子的最终后缀长度。但是实际上这里应该用inf代替，因为插入时并不知道叶子的最终后缀长度。

```cpp
void make(int u,int v){fa[u]=v;ch[v][pos[u][len[v]+1]]=u;}//连父亲
void push_back(const int &c)//叫push_back说明了什么（
{
    int pre=0;//用于记录ac的移动路径，便于添加Suffix Link
    ++rm;
    while(rm)
    {
        if(rm<=len[ac])
        {
            if(pos[ac][rm]==c) break;//被当前活动边隐式包含
            int nq=++tot;//插入一个节点
            len[nq]=rm-1;
            pos[nq]=pos[ac];
            nxt[nq]=1;
            make(nq,fa[ac]),make(ac,nq);
            ac=nq;
        }
        else if(ch[ac][c]) break;//被新的活动点隐式包含
        int u=++tot;//插入一个叶子节点
        pos[u]=&c-rm;
        len[u]=n-((int *)pos[u]-s)-1;//提前处理叶子的len
        make(u,ac);
        --rm;
        pre=ac;acs=u;
        if(ac!=1)
        {
            ac=nxt[fa[ac]];//跳Suffix Link
            for(const int *ps=&c-rm;len[ac]<rm-1;ac=ch[ac][ps[len[ac]+1]]);//如果存在已有的节点直接转移
            //ps就是队首指针
        }
    }
    if(pre>1) nxt[pre]=ac;//设置Suffix Link
    if(rm>len[ac]) ac=ch[ac][c];//如果加入的字符串超过活动边，就直接更新活动点
}
```
如果要动态统计呢？

这里有一个结论：加入一个字符后增加的本质不同子串数量等于叶子数。考虑具体如何证明：

首先，增加的本质不同子串是加入后字符串的大于某个值的后缀。

然后考虑上一次加入一个字符后新的本质不同子串，显然在其后面加上一个字符仍然是一个新的本质不同子串。

那么接下来就是上一次加入一个字符后重复的串。而“重复”的定义恰好就是“隐式包含”，而隐式包含的串就在队列中。

所以，每弹出一个队列中的元素，就会多一个本质不同子串，对应叶子数+1。

所以把上面的代码 `--rm;` 后加一句 `++lev;`，然后每次加入结束后将 `ans+=lev` 即可。

---
你可能会问了：这玩意建出来的树是和后缀树一样的，代码比后缀树还**难写**，有什么用吗？

这就关系到一个重要的应用了：双向后缀树。

可以发现，这种建法建后缀树是**从前往后**加字符的，而SAM的后缀树建法则是**从后往前**加字符的。

而两种建法建出的后缀树又是本质相同的。那么是不是可以通过某种手段，达到双向加字符的目的呢？

答案是肯定的，但是这个过程有点繁琐。因为后缀树的 Link 与隐式后缀树不同，其实后缀树的 Link 是转移边，而隐式后缀树则更类似于 AC 自动机的 fail 边。

首先先处理向后加字符。具体来说，我们只会在插入一个节点时对 Link 产生影响，所以此时需要额外转移。

我们先讨论插入一个非叶子节点的情况。可以发现这完全等同于SAM的复制一个节点，直接赋值即可。

然后是插入一个叶子 $u$。具体的分类讨论有些复杂。

首先有 $ac\rightarrow pre,u\rightarrow acs$，如果还不存在 $pre$，就有 $ac\rightarrow acs$。但是这里需要注意的是，根不应当被作为任何转移边的结尾，所以需要特判。

如果 $ac=1$，需要额外链接 $1\rightarrow u$。

然后当 $ac$ 跳转移边时，每次都要连接 $ac\rightarrow pre$。

最后结束时连接 $ac\rightarrow pre$。
