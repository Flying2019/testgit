### [链接](http://115.236.49.52:83/contest/1678/problem/3)
考虑 $n=10^5$ 还放5s，大概率是 $O(n^?)$ 的玄学复杂度了。

往分块方面想。首先显然有一种 $O(n^2)$ 的暴力，就是直接统计出所有数字的两两的距离。预处理 $O(n^2)$，单次询问 $O(1)$，修改 $O(n^2)$。

考虑优化。我们假设分块的大小为 $B$。按照这种暴力，我们统计出块内的所有数字两两的距离，再统计出每个块中每个数字的最左端和最右端。因为在块外，只有这些数字可能会有更优的答案。

然后询问的时候直接用两个指针存当前的 $x,y$ 的最右端 $p_x,p_y$，然后新加一个块时，用这个块的左端点 $l_x,l_y$ 与最右端的差，即 $l_x-p_y,l_y-p_x$ 去更新答案，再用块内去更新答案即可。这样复杂度一次是 $O(\frac n B)$。

对于修改，可以直接整块打tag，边角直接暴力重构。重构也是直接暴力指针扫一遍，然后统计每个点最左端和最右端即可。复杂度单次 $O(B^2)$。

所以总复杂度为 $O(nB+mB^2+\frac{nm}{B})$。取 $B=n^{\frac 1 3}$ 时得 $O(n^{\frac 5 3})$ 最优秀，可以卡过。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#define N 100010
#define M 81
#define B N/M+3
using namespace std;
int a[N];
int tag[B+5];
struct BLO{
	int id[N],nid[B],tid,L,R;
	int dis[M+3][M+3],pr[M+3],sf[M+3];
	int* operator [](int x){return dis[x];}
	void build()
	{
		for(int i=1;i<=tid;i++) id[nid[i]]=0;
		memset(nid,0,sizeof(nid));tid=0;
		for(int i=L;i<=R;i++)
		if(!id[a[i]]) nid[id[a[i]]=++tid]=a[i];
		memset(sf,0,sizeof(sf));memset(pr,0x3f,sizeof(pr));
		memset(dis,0x3f,sizeof(dis));
		for(int i=L;i<=R;i++)
		{
			int u=id[a[i]];
			sf[u]=i;
			pr[u]=min(pr[u],i);
			for(int j=1;j<=tid;j++)
			if(sf[j]) dis[j][u]=dis[u][j]=min(dis[u][j],sf[u]-sf[j]);
		}
	}
}b[B];
int read()
{
	int x=0,ch=0;
	for(;ch<'0' || ch>'9';ch=getchar());
	for(;ch>='0' && ch<='9';ch=getchar()) x=x*10+ch-'0';
	return x;
}
#define inf 100000000
inline void push_tag(int x){if(!tag[x]) return;for(int i=b[x].L;i<=b[x].R;i++) a[i]=tag[x];tag[x]=0;}
inline void set_bl(int x,int y,int v){int bl=x/M;push_tag(bl);for(int i=x;i<=y;i++) a[i]=v;b[bl].build();}

int main()
{
	int n,m,T;
	scanf("%d%d%d",&n,&m,&T);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=0;i<B;i++) b[i].L=n+1;
	for(int i=1;i<=n;i++) b[i/M].L=min(b[i/M].L,i),b[i/M].R=max(b[i/M].R,i);
	for(int i=0;i*M-M<=n;i++) b[i].build();
	int las=0;
	for(int i=1;i<=m;i++)
	{
		las*=T;
		int opt=read(),l=read()^las,r=read()^las,x;
		if(opt==1)
		{
			x=read()^las;
			int bl=l/M,br=r/M;
			if(bl==br) set_bl(l,r,x);
			else set_bl(l,b[bl].R,x),set_bl(b[br].L,r,x);
			for(int i=bl+1;i<br;i++) tag[i]=x;
		}
		else
		{
			int px=-inf,py=-inf,ans=inf;
			if(l==r)
			{
				ans=-1;
				for(int i=0;i*M-M<=n;i++)
				if(tag[i]==l || b[i].id[l]) ans=0;
				printf("%d\n",ans);
				las=max(ans,0);
				continue;
			}
			for(int i=0;i*M-M<=n;i++)
			if(tag[i])
			{
				if(l==tag[i]) px=b[i].R,ans=min(ans,b[i].L-py);
				if(r==tag[i]) py=b[i].R,ans=min(ans,b[i].L-px);
			}
			else
			{
				ans=min(ans,b[i][b[i].id[l]][b[i].id[r]]);
				if(b[i].id[l]) ans=min(ans,b[i].pr[b[i].id[l]]-py);
				if(b[i].id[r]) ans=min(ans,b[i].pr[b[i].id[r]]-px);
				if(b[i].id[l]) px=b[i].sf[b[i].id[l]];
				if(b[i].id[r]) py=b[i].sf[b[i].id[r]];
			}
			printf("%d\n",ans>n?-1:ans);
			las=ans>n?0:ans;
		}
	}
	return 0;
}
```
