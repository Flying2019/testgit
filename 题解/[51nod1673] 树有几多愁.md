### [链接](http://www.51nod.com/Challenge/Problem.html#problemId=1673)
为了方便，我们可以把题目看成给每个点赋一个权值 $w_i$，其中 $w_i$ 构成一个排列，要每个叶子到根的路径上最小的点权的乘积最大。

由于题目条件比较多，首先考虑贪心。

可以发现，如果存在一个点 $u$ 和其祖先 $v$ 有 $w_u>w_v$，可以发现交换 $w_u$，$w_v$ 一定不会更劣。

显然还有一个性质：如果存在一条链，其中不存在任何分岔。可以发现其顶端到低端的权值应当是连续递增的。

比如考虑一个点 $u$ 的权值是1（当然根据上一个性质它一定是叶子），存在一条 $f\rightarrow u,(f\text{是}u\text{的祖先})$ 的长度为4的链不存在任何分岔，这条链的权值应当依次是4,3,2,1。

考虑为什么：反正 $u$ 这个点（所包含的叶子节点）的权值已经确定了，$f\rightarrow u$ 这条链的值只要比 $w_u$ 大就不会有任何影响，不妨把剩下能取的最小的数字扔到这条链上，让其他点有更大的权值。

根据贪心，我们从小往大给 $w_i$ 赋值。很明显，假如我们确定了叶子节点的权值赋值的顺序，按照上述方式依次赋值，那么最后的结果就是唯一的。

可以发现链上的点完全是用于扔“不需要用”的权值。不妨直接换成一条带权的边方便处理。这个直接暴力建虚树即可。

可以发现，对于一个叶子集合 $S$，它会赋值的点是确定的。所以不妨状压dp，用 $f_{S}$ 表示叶子集合 $S$ 中的点被赋值后最大的结果。

由于叶子集合比较大，所以我们考虑预处理每个集合 $S$ 被赋值后会赋值的总点数。

特别的，这道题数字比较大，好像直接高精度会T。不妨直接取log，以log后的结果比较即可。

复杂度 $O(2^n\times n)$。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<cmath>
#define mod 1000000007
using namespace std;
#define N 100010
#define S 1<<20
double f[S];
int g[S],sum[S];
vector<int>rd[N],r[N];
int suf[N],dep[N],fa[N];
int lev[N],tot;
int sf[N],siz[N];
void dfs(int u,int pre)
{
    int s=0;
    siz[u]=1;
    dep[u]=dep[pre]+1;
    if(rd[u].size()>2 || u==1) suf[u]=u;
    if(u!=1 && rd[u].size()==1){suf[u]=u;sf[u]=1<<tot;lev[tot++]=u;return;}
    for(int v:rd[u])
    {
        if(v==pre) continue;
        dfs(v,u);
        if(!suf[u]) suf[u]=suf[v];
        sf[u]|=sf[v];
        siz[u]+=siz[v];
    }
    if(suf[u]==u){
        for(int v:rd[u])
        if(v!=pre) fa[suf[v]]=u,r[u].push_back(suf[v]);
    }
}
int check(int u,int s)
{
    if((sf[u]&s)==sf[u]) return siz[u]+dep[u]-dep[fa[u]]-1;
    int ans=0;
    for(int v:r[u])
        if(sf[v]&s) ans+=check(v,sf[v]&s);
    return ans;
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<n;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        rd[u].push_back(v);rd[v].push_back(u);
    }
    dfs(1,0);
    int m=1<<tot;
    for(int i=1;i<m;i++) sum[i]=check(1,i),f[i]=g[i]=-1e15;
    f[0]=0,g[0]=1;
    for(int u=0;u<m;u++)
    {
        for(int i=0;i<tot;i++)
        if(!((u>>i)&1))
        {
            int t=u|(1<<i);
            double s=f[u]+log(sum[u]+1);
            if(f[t]<s) f[t]=s,g[t]=1ll*g[u]*(sum[u]+1)%mod;
        }
    }
    printf("%d",g[m-1]);
    return 0;
}
```
