### [链接](https://www.luogu.com.cn/problem/P6292)
按照套路，我们把询问离线。可以发现，对于某个串，如果我们统计出对于 $[1,r]$ $T$第一次出现的位置 $a$ 和最后一次出现的位置 $las$，那么字符串 $T$ 对于 $l\in[a,las+|T|]$ 会产生1的贡献。

考虑如何统计。我们考虑模拟SAM插入字符的过程，可以发现它本质是将它到其父亲的 $las$ 修改为 $r$。而“将当前点到根的路径上所有边修改”本质就是LCT的access操作。

所以我们不妨先预处理出parent树。可以发现，对于LCT的每次splay操作，只需要修改虚实子树信息即可。这段修改可以用线段树维护，时间复杂度 $O(n\log^2 n)$。
```cpp#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#define N 400010
#define C 26
#define ll long long
using namespace std;
namespace SAM{
    int ch[N][C],fa[N],len[N],las=1,cnt=1;
    int insert(int c)
    {
        int p=las,q=las=++cnt;
        len[q]=len[p]+1;
        for(;p && !ch[p][c];p=fa[p]) ch[p][c]=q;
        if(!p) fa[q]=1;
        else
        {
            int np=ch[p][c];
            if(len[np]==len[p]+1) fa[q]=np;
            else
            {
                int nq=++cnt;
                memcpy(ch[nq],ch[np],sizeof(ch[nq]));
                len[nq]=len[p]+1;
                fa[nq]=fa[np];
                fa[np]=fa[q]=nq;
                for(;p && ch[p][c]==np;p=fa[p]) ch[p][c]=nq;
            }
        }
        return q;
    }
}
namespace ST{
    ll val[N<<2],tag[N<<2];
    void push_down(int u,int l,int r)
    {
        if(!tag[u]) return;
        int mid=(l+r)>>1;
        val[u<<1]+=(mid-l+1)*tag[u];
        val[u<<1|1]+=(r-mid)*tag[u];
        tag[u<<1]+=tag[u];
        tag[u<<1|1]+=tag[u];
        tag[u]=0;
    }
    void insert(int u,int l,int r,int L,int R,int v)
    {
        if(L<=l && r<=R){tag[u]+=v;val[u]+=v*(r-l+1);return;}
        push_down(u,l,r);
        int mid=(l+r)>>1;
        if(L<=mid) insert(u<<1,l,mid,L,R,v);
        if(R>mid) insert(u<<1|1,mid+1,r,L,R,v);
        val[u]=val[u<<1]+val[u<<1|1];
    }
    ll answer(int u,int l,int r,int L,int R)
    {
        if(L<=l && r<=R) return val[u];
        push_down(u,l,r);
        int mid=(l+r)>>1;
        if(R<=mid) return answer(u<<1,l,mid,L,R);
        if(L>mid) return answer(u<<1|1,mid+1,r,L,R);
        return answer(u<<1,l,mid,L,R)+answer(u<<1|1,mid+1,r,L,R);
    }
}
namespace LCT{
    int ch[N][2],fa[N],las[N],tag[N],len[N],val[N];
    bool nroot(int u){return ch[fa[u]][0]==u || ch[fa[u]][1]==u;}
    void update(int u){val[u]=min(len[u],min(val[ch[u][0]],val[ch[u][1]]));}
    void rotate(int u)
    {
        int f=fa[u],ff=fa[f];
        int k=ch[f][1]==u,v=ch[u][!k];
        if(nroot(f)) ch[ff][ch[ff][1]==f]=u;
        ch[f][k]=v;
        ch[u][!k]=f;
        if(v) fa[v]=f;
        fa[f]=u;
        fa[u]=ff;
        update(f),update(u);
    }
    void push_down(int u){if(!tag[u]) return;las[ch[u][0]]=tag[ch[u][0]]=las[ch[u][1]]=tag[ch[u][1]]=tag[u];tag[u]=0;}
    void push_all(int u){if(nroot(u)) push_all(fa[u]);push_down(u);}
    void splay(int x)
    {
        push_all(x);
        while(nroot(x))
        {
            int f=fa[x];
            if(nroot(f)) rotate((ch[fa[f]][0]==f)^(ch[f][0]==x)?fa[x]:x);
            rotate(x);
        }
        update(x);
    }
    void access(int x,int c)
    {
        int u=x;
        for(int y=0;x;y=x,x=fa[x])
        {
            splay(x);
            ch[x][1]=y;update(x);
            if(las[x]) ST::insert(1,1,N-10,las[x]-SAM::len[x]+1,las[x]-val[x]+1,-1);
        }
        splay(u),las[u]=tag[u]=c;
        ST::insert(1,1,N-10,c-SAM::len[u]+1,c,1);
    }
    void init()
    {
        val[0]=100000000;
        for(int i=1;i<=SAM::cnt;i++) val[i]=len[i]=SAM::len[SAM::fa[i]]+1,fa[i]=SAM::fa[i];
    }
}
ll ans[N];
struct node{
    int l,u;
    node(int L=0,int U=0):l(L),u(U){}
};
vector<node>q[N];
int pos[N];
char str[N];
int main()
{
    int n,m;
    scanf("%s%d",str+1,&m);
    n=strlen(str+1);
    for(int i=1;i<=m;i++)
    {
        int l,r;
        scanf("%d%d",&l,&r);
        q[r].push_back(node(l,i));
    }
    for(int i=1;i<=n;i++) pos[i]=SAM::insert(str[i]-'a');
    LCT::init();
    for(int i=1;i<=n;i++)
    {
        LCT::access(pos[i],i);
        for(auto u:q[i]) ans[u.u]=ST::answer(1,1,N-10,u.l,i);
    }
    for(int i=1;i<=m;i++)
    printf("%lld\n",ans[i]);
    return 0;
}
```
