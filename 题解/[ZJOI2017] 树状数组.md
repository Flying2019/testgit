### [链接](https://loj.ac/problem/2251)
~~题面过于真实~~。考虑题面中写错的这个代码本质是求后缀和。本来求后缀和也是对的，但是这时求的是和是 $\sum_{i=l-1}^{r-1}a_i$。所以询问正确当且仅当 $a_{l-1}==a_r$。

也就是要维护数对 $(l,r)$ 相同的概率。很明显，如果原来 $(l,r)$ 相同的概率为 $P$，被修改的概率为 $Q$，那么新的概率就是 $P\times Q\ +\ (1-P)\times(1-Q)$。

很显然这是一个二维区间修改，区间查询的问题。直接上树套树即可。

复杂度 $O(n\log^2 n)$。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#define N 100010
#define M N*360
#define mod 998244353
#define ll long long
using namespace std;
int add(int x,int y){return (1ll*(1-x)*(1-y)%mod+1ll*y*x+mod)%mod;}
int ksm(int a,int b=mod-2)
{
	int r=1;
	for(;b;b>>=1)
	{
		if(b&1) r=1ll*r*a%mod;
		a=1ll*a*a%mod;
	}
	return r;
}
int n,m;
struct seg_seg_tree{
	int val[M];
	int ls[M],rs[M],rt[N<<2],cnt;
	void insert(int &u,int l,int r,int L,int R,int v)
	{
		if(L>R) return;
		if(!u){u=++cnt;val[u]=1;}
		if(L<=l && r<=R){val[u]=add(val[u],v);return;}
		int mid=(l+r)>>1;
		if(L<=mid) insert(ls[u],l,mid,L,R,v);
		if(R>mid) insert(rs[u],mid+1,r,L,R,v);
	}
	int answer(int u,int l,int r,int p)
	{
		if(!u)return 1;
        if(r==l)return val[u];
		int mid=(l+r)>>1;
        if(p<=mid) return add(val[u],answer(ls[u],l,mid,p));
        else return add(val[u],answer(rs[u],mid+1,r,p));
	}
	void insert(int u,int l,int r,int L,int R,int ql,int qr,int v)
	{
		if(L<=l && r<=R){insert(rt[u],1,n,ql,qr,v);return;}
		int mid=(l+r)>>1;
		if(L<=mid)insert(u<<1,l,mid,L,R,ql,qr,v);
		if(R>mid) insert(u<<1|1,mid+1,r,L,R,ql,qr,v);
	}
	int answer(int u,int l,int r,int p,int x)
	{
		if(l==r) return answer(rt[u],1,n,x);
		int mid=(l+r)>>1;
		if(p<=mid) return add(answer(rt[u],1,n,x),answer(u<<1,l,mid,p,x));
		else return add(answer(rt[u],1,n,x),answer(u<<1|1,mid+1,r,p,x));
	}
}t;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
    {
        int opt,l,r;
        scanf("%d%d%d",&opt,&l,&r);
        if(opt==1)
        {
        	int p=ksm(r-l+1);
        	if(l!=1)
        	{
				t.insert(1,0,n,1,l-1,l,r,(1-p+mod)%mod);
	        	t.insert(1,0,n,0,0,1,l-1,0);
			}
        	if(r!=n)
			{
				t.insert(1,0,n,l,r,r+1,n,(1-p+mod)%mod);
				t.insert(1,0,n,0,0,r+1,n,0);
			}
			t.insert(1,0,n,l,r,l,r,(1-2ll*p%mod+mod)%mod);
			t.insert(1,0,n,0,0,l,r,p);
        }
        else printf("%d\n",t.answer(1,0,n,l-1,r));
    }
	return 0;
}

```
