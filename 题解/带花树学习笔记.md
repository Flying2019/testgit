### [模板](http://uoj.ac/problem/79)
带花树一类是在 $O(n^3)$ 内解决一般图最大匹配问题的算法。

首先考虑二分图最大匹配算法在一般图上为什么不行：可以发现，二分图最大匹配要求每个点黑白染色，所有边都是黑点与白点之间的边。

所以我们不妨仿照二分图匹配，**尝试**将图黑白染色，然后将需要匹配的黑色节点压入队列BFS查询匹配。

但是一般图我们并不能直接黑白染色，因为存在奇环下不同遍历顺序最后的结果不同。

我们必须考虑如何处理奇环。可以发现，一个奇环中只有一个点可以向外界连边，而我们在环中总是能**腾出恰好一个点**使这个点没有匹配。可以发现这等价于一个点。

那么我们显然可以将一个奇环缩成一个点处理。由于我们只对黑点跑匹配，可以发现这种情况下进入奇环的点一定是黑的。那么假如我们要腾出一个点，那么这个点也一定是黑的。

所以为了方便，我们将所有奇环上的点染成黑色，对于新增的黑色节点压入队列，然后将所有点用并查集缩到环的根上。对于环内我们记录一个数组 $pre$ 表示转移的路径，以便后续修改方便。

特别的，由于我们用的是BFS，奇环上的两个点相遇时深度一定相同，所以直接交换取fa修改即可。

对于其他部分，基本与匈牙利算法相同。时间复杂度 $O(n^3)$。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define N 510
#define M 125000
using namespace std;
int nxt[M<<1],to[M<<1],head[N],cnt;
void add(int u,int v)
{
    nxt[++cnt]=head[u];
    to[cnt]=v;
    head[u]=cnt;
}
int f[N],vis[N],tvis;
int link[N],pre[N];
int find(int x){return x==f[x]?f[x]:(f[x]=find(f[x]));}
int lca(int x,int y)
{
    tvis++;
    for(x=find(x),y=find(y);vis[x]!=tvis;)
    {
        vis[x]=tvis;
        x=find(pre[link[x]]);
        if(y) swap(x,y);
    }
    return x;
}
int clr[N],n;
queue<int>q;
void merge(int x,int y,int v)
{
    for(;find(x)!=v;x=pre[y])
    {
        pre[x]=y;y=link[x];
        if(clr[y]==2) clr[y]=1,q.push(y);
        if(x==find(x)) f[x]=v;
        if(y==find(y)) f[y]=v;
    }
}
bool check(int s)
{
    while(!q.empty()) q.pop();
    for(int i=1;i<=n;i++) f[i]=i,pre[i]=clr[i]=0;
    q.push(s);
    clr[s]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=head[u];i;i=nxt[i])
        {
            int v=to[i];
            if(find(u)==find(v) || clr[v]==2) continue;
            if(clr[v]==0)
            {
                clr[v]=2,pre[v]=u;
                if(!link[v])
                {
                    for(int x=v,y;x;x=y) y=link[pre[x]],link[x]=pre[x],link[pre[x]]=x;
                    return true;
                }
                else clr[link[v]]=1,q.push(link[v]);
            }
            else{int w=lca(u,v);merge(u,v,w);merge(v,u,w);}
        }
    }
    return false;
}
int main()
{
    int m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        add(u,v),add(v,u);
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    if(!link[i]) ans+=check(i);
    printf("%d\n",ans);
    for(int i=1;i<=n;i++) printf("%d ",link[i]);
    return 0;
}
```
