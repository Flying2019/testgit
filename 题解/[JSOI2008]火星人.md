#### [题目链接](https://www.luogu.com.cn/problem/P4036)
## 题目大意
给定一个字符串。支持修改、插入字符操作。动态查询两个后缀的lcp。

$n\leq 150000$
## 解题思路
因为是动态查询，还要插入字符，那么SA和SAM估计没戏了。

既然要求lcp，除去SA后最方便的就是Hash了。

因为LCP也具有可二分性。对于字符串$s_1,s_2$，其中$j,i$是$s_1$的前缀，$j<i$，并且$i$是$s1,s2$的前缀，则$j$也是$s1,s2$的前缀。

所以通过二分可以在$O(\log n)$时间求出两个串的前缀。

又考虑到Hash是可合并的（即知道左右区间的Hash值即可推出总区间的Hash值），所以可以直接套上平衡树即可。

时间复杂度$O(n\log^2 n)$
## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
using namespace std;
#define N 200010
#define ull unsigned long long
const ull base=43;
ull bases[N];
struct Ftreap{
	int ch[N][2],siz[N],rnd[N];
	ull val[N],sum[N];
	int tot;
	inline void update(int u)
	{
		siz[u]=siz[ch[u][0]]+siz[ch[u][1]]+1;
		sum[u]=sum[ch[u][0]]*bases[siz[ch[u][1]]+1]+val[u]*bases[siz[ch[u][1]]]+sum[ch[u][1]];
	}
	inline int new_node(ull v)
	{
		siz[++tot]=1;
		sum[tot]=val[tot]=v;
		ch[tot][0]=ch[tot][1]=0;
		rnd[tot]=rand();
		return tot;
	}
	int merge(int x,int y)
	{
		if(!x || !y) return x+y;
		if(rnd[x]<rnd[y])
		{
			ch[x][1]=merge(ch[x][1],y);
			update(x);
			return x;
		}
		else
		{
			ch[y][0]=merge(x,ch[y][0]);
			update(y);
			return y;
		}
	}
	void split(int u,int k,int &lt,int &rt)
	{
		if(u==0){lt=rt=0;return;}
		if(siz[ch[u][0]]<k)
		{
			lt=u;
			split(ch[u][1],k-siz[ch[u][0]]-1,ch[u][1],rt);
		}
		else
		{
			rt=u;
			split(ch[u][0],k,lt,ch[u][0]);
		}
		update(u);
	}
	int lt,rt,mt;
	ull answer(int &root,int l,int r)
	{
		split(root,l-1,lt,mt);
		split(mt,r-l+1,mt,rt);
		ull ans=sum[mt];
		root=merge(lt,merge(mt,rt));
		return ans;
	}
	void insert(int &root,int p,ull v)
	{
		split(root,p,lt,rt);
		root=merge(lt,merge(new_node(v),rt));
	}
	void erase(int &root,int p)
	{
		split(root,p,lt,rt);
		split(lt,p-1,lt,mt);
		mt=merge(ch[mt][0],ch[mt][1]);
		root=merge(lt,merge(mt,rt));
	}
}t;
int n,root;
char str[N],opt[2];
int lcp(int x,int y)
{
	int l=1,r=min(n-x+1,n-y+1),ans=0;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(t.answer(root,x,x+mid-1)==t.answer(root,y,y+mid-1)) l=mid+1,ans=mid;
		else r=mid-1;
	}
	return ans;
}
int main()
{
	srand(19260817);
	scanf("%s",str+1);
	int m;
	scanf("%d",&m);
	n=strlen(str+1);
	bases[0]=1;
	for(int i=1;i<=100000;i++) bases[i]=bases[i-1]*base;
	for(int i=1;i<=n;i++) root=t.merge(root,t.new_node(str[i]-'a'+1));
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%s%d",opt,&x);
		if(opt[0]=='Q')
		{
			scanf("%d",&y);
			printf("%d\n",lcp(x,y));
		}
		else if(opt[0]=='R')
		{
			scanf("%s",opt);
			t.erase(root,x);
			t.insert(root,x-1,opt[0]-'a'+1);
		}
		else if(opt[0]=='I')
		{
			scanf("%s",opt);
			t.insert(root,x,opt[0]-'a'+1);
			n++;
		}
	}
	return 0;
}
```
