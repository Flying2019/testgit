### [链接](https://loj.ac/problem/3339)
### 题目大意
给定一个无向图，点有点权表示贡献，边有边权表示通过时间。保证边权 $w_i\in[1,5]$。

再给定 $k$ 组特殊贡献，即如果在 $t_i$ 时间到达 $u_i$，则可以加上 $v_i$ 的贡献。

要求在 $t$ 的时间后恰好走回1，求最大化贡献。
### 题解
很套路的题，可我太菜还是翻车了。

考虑如果没有边权和特殊贡献，这就是一道经典的矩阵转移。

具体来说，考虑重新定义矩阵乘法 $A=B\times C$：
$$A_{i,j}=\max_{k\leq n}\left(B_{i,k}+C_{k,j}\right)$$

然后初始 $A_{i,j}$ 表示 $i\rightarrow j$ 的贡献。

这十分符合最大化贡献的性质，但是这求的边权最大化。考虑点权转边权，即定义每条边的边权为其到达的点权即可。

然后定义 $U$ 表示初始列向量，即 $U_1=1\ ,\ \forall\ i>1\ ,\ U_i=\inf$。那么答案列向量 $B=U\times A^t$，$B_1$ 就是答案。

直接矩阵快速幂，时间复杂度 $O(n^3\log t)$。

考虑有边权的情况。可以发现边的通过时间很小，那么我们考虑在边上建那么多个点表示转移。这样是 $O((wm+n)^3\log t)$，会TLE。

我们考虑我们并不需要知道它在第一步时往哪里走，所以直接拆点 $a_1,a_2,a_3,a_4,a_5$ 表示在路上花费的时间，即从 $a_i$ 走到 $v$ 表示 $a$ 经过 $i$ 步走到 $v$。显然连边 $a_1\rightarrow a_2\rightarrow a_3\rightarrow a_4\rightarrow a_5$ ，然后按照上文方式处理即可。时间复杂度 $O\left((wn)^3\log t\right)$

接下来考虑额外贡献。按照套路，对 $k$ 个时间排序，每个时间点从上一个时间点用矩阵快速幂转移，直接更新，时间复杂度 $O((wn)^3k\log t)$，显然会T。

考虑优化。我们发现矩阵快速幂中我们把 $I,A,A^2,A^4,A^8\cdots$ 这些部分重复计算了许多遍，而 $A$ 数组实际上并不会发生改变，所以直接离线处理。即令 $A_i'=A^{2^{i}}$

然后考虑对于时间 $t$，处理二进制分解结果 $t_i$，有答案 $B=U\prod_{i} A_{t_i}'$。

考虑列向量乘矩阵可以直接 $O(n^2)$ 处理，所以总时间复杂度 $O\left((wn)^3\log t+(wn)^2klog t\right)$，可以通过。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 310
#define M 1010
#define ll long long
using namespace std;
int nxt[M<<1],to[M<<1],w[M<<1],head[N],cnt;
void add(int u,int v,int w1)
{
    nxt[++cnt]=head[u];
    to[cnt]=v;
    w[cnt]=w1;
    head[u]=cnt;
}
struct extra{
    int t,x,v;
}q[510];
ll c[N],f[55010][N];
namespace c1{
    #define inf 1e16
    using namespace std;
    struct matrix{
        ll num[N][N];
        matrix(){for(int i=0;i<N-10;i++)for(int j=0;j<N-10;j++) num[i][j]=-inf;}
        ll* operator [](int a){return num[a];}
    }swp,a,to[40];
    int n;
    matrix operator *(matrix &a,matrix &b)
    {
        swp=matrix();
        for(int k=1;k<=n;k++)
            for(int i=1;i<=n;i++)
                for(int j=1;j<=n;j++)
                swp[i][j]=max(swp[i][j],a[i][k]+b[k][j]);
        return swp;
    }
    struct line{
        ll num[N];
        ll& operator [](int a){return num[a];}
        line(){for(int i=0;i<N-10;i++) num[i]=-inf;}
    }o;
    line operator *(line &a,matrix &b)
    {
        line c;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
            c[j]=max(c[j],a[i]+b[i][j]);
        return c;
    }
    void ksm(line &o,matrix a,ll b)//o*=a^b
    {
        for(int i=0;1ll<<i<=b;i++)
        if((b>>i)&1) o=o*to[i];
    }
    struct extra{
        ll t,x,v;
        bool operator <(const extra a)const{return t<a.t;}
    }q[510];
    ll c[N];
    void main(int n1,int m,ll t,int k)
    {
        n=n1;
        for(int i=1;i<=n;i++) scanf("%lld",&c[i]);
        if(m>50)
        {
            for(int i=1;i<=n;i++)
                for(int _=0;_<=3;_++) a[_*n+i][(_+1)*n+i]=0;
            for(int i=1;i<=m;i++)
            {
                int u,v,w;
                scanf("%d%d%d",&u,&v,&w);
                a[(w-1)*n+u][v]=c[v];
            }
            n*=5;
        }
        else
        {
            for(int i=1;i<=m;i++)
            {
                int u,v,w;
                scanf("%d%d%d",&u,&v,&w);
                int p=u;
                for(int l=1;l<w;l++) ++n,a[p][n]=c[n],p=n;
                a[p][v]=c[v];
            }
        }
        for(int i=1;i<=k;i++) scanf("%lld%lld%lld",&q[i].t,&q[i].x,&q[i].v);
        q[++k]=(extra){t,1,c[1]};
        sort(q+1,q+k+1);
        o[1]=0;
        to[0]=a;
        for(int i=1;1<<i<=t;i++) to[i]=to[i-1]*to[i-1];
        for(int i=1;i<=k;i++)
        {
            ksm(o,a,q[i].t-q[i-1].t);
            if(o[q[i].x]>=0) o[q[i].x]+=q[i].v;
        }
        printf("%lld\n",o[1]>=0?o[1]:-1);
    }
}
int main()
{
    // freopen("delicacy.in","r",stdin);
    // freopen("delicacy.out","w",stdout);
    int n,m,k;
    ll t;
    scanf("%d%d%lld%d",&n,&m,&t,&k);
    c1::main(n,m,t,k);
    return 0;
}
```
