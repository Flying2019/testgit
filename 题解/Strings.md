### [链接](https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102652/problem/B)
### 题目大意
给定一个字符串。有一个其子序列构成的集合。最开始集合中有一个元素是空集。每次A和B可以选取集合中的一个子序列，构建至少一个互不相同的字符串 $t_i$ 为在其后面加上一个字符，然后将原序列删去后插入这些字符串。要求所有字符串均为原串的子序列。

不能操作者输。
### 题解
考虑如果我们把每个子序列看成一个点，能转移的点之间连边，可以发现这些点构成了一颗树。

假设我们能处理出这些点，那么题目就变成：给你一颗有根树，其中根是黑色的。A和B轮流操作，每次可以选择一个非叶子的黑色节点，将其染成白色，然后将至少一个儿子节点染成黑色。不能操作者输。

可以发现这是典型的博弈论。假设我们算出了当前点 $u$ 的所有儿子节点的SG值 $v_son_i$，令集合 $S$ 表示由若干 $son_i$ 组成的集合的集合，可以发现

$$v_i=\operatorname{mex}\{{s\in S\ |\ \bigoplus_{i\in s}\ v_i}\}$$

根据线性基可以发现此时的 $\operatorname{mex}$ 就是线性基中第一个没有出现的数字。

再考虑处理出树上的点。由于题目要求子序列，直接上序列自动机即可，复杂度$O(n\log a)$。
