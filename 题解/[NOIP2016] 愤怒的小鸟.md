### [链接](https://www.luogu.com.cn/problem/P2831)
这道题用状压dp显然可以做而且挺可写的。但是暴力/状压的题怎么能没有DLX呢。

首先我们处理出所有可以经过至少2个点的抛物线，定义一个01矩阵，其中 $a_{i,j}$ 表示第 $i$ 个抛物线是否经过第 $j$ 个点。

那么我们要做的就是选取最少的行，使每一列**至少**有一个1。

首先显然这是**重复覆盖问题**，DLX虽然能处理，但是非常的慢（亲测最多只有90），因为它并不能进行很多有效剪枝。

我们考虑这道题有什么限制：$x,y<10$ 且只有两位小数。可以发现，这种情况下只有少数点可以共用一根抛物线。

这意味着什么？其实每一行1的个数非常的少。而我们知道DLX处理完全覆盖问题比重复覆盖问题的效率高太多。

所以我们直接暴力将所有可行组合代替原来的“抛物线”，即我们认为一个小鸟可以选择是否消灭某个在抛物线上猪，然后要求猪只能死一次。

这样我们就可以套上完全覆盖问题的DLX做法，实测跑得飞快（指相比较某些暴力剪枝和重复覆盖问题的DLX）。
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#define N 500010
#define re register
using namespace std;
int l[N],r[N],u[N],d[N];
int nx[N],ny[N];
int h[N],s[N],cnt;
void init(int m)
{ 
	for(int i=0;i<=m;i++) r[i]=i+1,l[i]=i-1,u[i]=d[i]=i;
	r[m]=0,l[0]=m;
	memset(h,-1,sizeof(h));
	memset(s,0,sizeof(s));
	cnt=m+1;
}
void insert(int x,int y)
{
	s[y]++;
	nx[cnt]=x,ny[cnt]=y;
	u[cnt]=y;
	d[cnt]=d[y];
	d[y]=u[d[y]]=cnt;
	if(h[x]==-1) h[x]=r[cnt]=l[cnt]=cnt;
	else
	{
		r[cnt]=h[x],l[cnt]=l[h[x]];
		l[h[x]]=r[l[h[x]]]=cnt;
	}
	++cnt;
}
void erase(int y)
{
	r[l[y]]=r[y];
	l[r[y]]=l[y];
	for(int i=d[y];i!=y;i=d[i])
		for(int j=r[i];j!=i;j=r[j]) u[d[j]]=u[j],d[u[j]]=d[j],s[ny[j]]--;
}
void renew(int y)
{
	for(re int i=u[y];i!=y;i=u[i])
		for(re int j=l[i];j!=i;j=l[j]) u[d[j]]=j,d[u[j]]=j,s[ny[j]]++;
	r[l[y]]=y;
	l[r[y]]=y;
}
int ans;
bool vis[N];
void work(int dep)
{
	if(r[0]==0){ans=min(ans,dep);return;}
    if(dep+1>=ans) return;
	int p=r[0];
	for(re int i=p;i;i=r[i]) if(s[i]<s[p]) p=i;
	erase(p);
	for(re int i=d[p];i!=p;i=d[i])
	{
		for(re int j=r[i];j!=i;j=r[j]) erase(ny[j]);
		work(dep+1);
		for(re int j=l[i];j!=i;j=l[j]) renew(ny[j]);
	}
	renew(p);
}
#define db double
#define eps 1e-7
struct node{
	db x,y;
}p[23];
int ncnt,m;
int rres[23];
void solve(int u,int v)
{
	db x1=p[u].x,y1=p[u].y,x2=p[v].x,y2=p[v].y;
    if(x1==x2) return ;
    db a=(y1*x2-y2*x1)/(x1*x1*x2-x2*x2*x1),b=(y1-a*x1*x1)/x1;
    if(a>=0) return;
    for(int i=1;i<u;i++)
    {
        db x=p[i].x,y=p[i].y;
        if(fabs(a*x*x+b*x-y)<=eps) return;
    }
    int tot=0;
    for(int i=u+1;i<=m;i++)
    {
        db x=p[i].x,y=p[i].y;
        if(fabs(a*x*x+b*x-y)<=eps) rres[tot++]=i;
    }
    for(int i=1;i<(1<<tot);i++)
    {
        ++ncnt;
        insert(ncnt,u);
        for(int j=0;j<tot;j++)
        if(i&(1<<j)) insert(ncnt,rres[j]);
    }
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t --> 0)
	{
		int l;
		scanf("%d%d",&m,&l);
		init(m);
		for(int i=1;i<=m;i++) scanf("%lf%lf",&p[i].x,&p[i].y);
		for(int i=1;i<=m;i++) insert(i,i);
		ncnt=m;
		for(int i=1;i<=m;i++)
			for(int j=i+1;j<=m;j++) solve(i,j);
		ans=100000000;
		work(0);
		printf("%d\n",ans);
	}
	return 0;
}
```
