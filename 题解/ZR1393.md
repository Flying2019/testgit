考虑两个排列的置换一定构成了一些循环，从循环入手，用一些组合计数的方法即可。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 500010
#define mod 998244353
#define ll long long
using namespace std;
int ksm(int a,int b=mod-2)
{
	if(b<0) return 0;
	int ans=1;
	for(;b;b>>=1)
	{
		if(b&1) ans=1ll*ans*a%mod;
		a=1ll*a*a%mod;
	}
	return ans;
}
int n,cnt[N],nxt[N];
ll f[N];
bool vis[N];
int main()
{
	int t;
	scanf("%d",&t);
	while(t --> 0)
	{
		int n;
		scanf("%d",&n);
		for(int i=1;i<=n;i++) f[i]=vis[i]=cnt[i]=0;
		for(int i=1;i<=n;i++) scanf("%d",&nxt[i]);
		for(int i=1;i<=n;i++)
		if(!vis[i])
		{
			int cir=1;
			for(int u=nxt[i];u!=i;u=nxt[u]) vis[u]=1,cir++;
			cnt[cir]++;
		}
		for(int i=1;i<=n;i++)
			for(int j=i*2;j<=n;j+=i)
			f[j]+=cnt[i]*i;
		int ans=0,u=2;
		if(cnt[1]==0) u=3,ans=ksm(2*cnt[2],cnt[2]-1);
		else if(cnt[1]==1) ans=1;
		else ans=ksm(cnt[1],cnt[1]-2);
		for(int i=u;i<=n;i++)
		if(cnt[i]) ans=1ll*ans*f[i]%mod*ksm(cnt[i]*i+f[i],cnt[i]-1)%mod;
		printf("%d\n",ans);
	}
	return 0;
}
```
心得：
1. 组合计数一些基本等式要记熟。
2. 要注意所有情况，分类讨论，不然直接爆0..
